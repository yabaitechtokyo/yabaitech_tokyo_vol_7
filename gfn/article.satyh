@require: itemize
@require: code
@require: base/image

@require: class-yabaitech/yabaitech

module Gfn : sig

  val article : block-text

end = struct

  let-inline ctx \no-break-latin it =
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let deco _ _ _ _ = [] in
    script-guard Latin (inline-frame-outer pads deco (read-inline ctx it))


  let-inline ctx \quad =
    inline-skip (get-font-size ctx *' 0.88)


  let-block ctx +image width height gf =
    line-break true true ctx
      (inline-fil ++ inline-graphics width height 0pt (gf ctx) ++ inline-fil)


  let bibliography = [
    (`GasterJones1996`, Article(|
      author = {| Benedict R. Gaster | Mark P. Jones |};
      title = {A polymorphic type system for extensible records and variants};
      journal = {Technical Report NOTTCS-TR-96-3};
      volume = None;
      number = None;
      pages = (1, 12);
      year = 1996;
    |));
    (`HewittBishopSteiger1973`, Article(|
      author = {| Carl Hewitt | Peter Bishop | Richard Steiger |};
      title = {A universal modular ACTOR formalism for artificial intelligence};
      journal = {IJCAI};
      volume = None;
      number = None;
      pages = (235, 245);
      year = 1973;
      % Morgan Kaufmann Publishers Inc.
    |));
    (`Honda1993`, Article(|
      % https://doi.org/10.1007/3-540-57208-2_35
      author = {| Kohei Honda |};
      title = {Types for dyadic interaction};
      journal = {Lecture Notes in Computer Science (CONCUR’93)};
      volume = Some(715);
      number = None;
      pages = (509, 523);
      year = 1993;
    |));
    (`HondaYoshidaCarbone2008`, InProceedings(|
      % https://doi.org/10.1145/1328438.1328472
      author = {| Kohei Honda | Nobuko Yoshida | Marco Carbone |};
      title = {Multiparty asynchronous session types};
      booktitle = {
        Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on
        Principles of Programming Languages
      };
      series = Some({POPL’08});
      volume = None;
      number = None;
      pages = (273, 284);
      year = 2008;
    |));
    (`LindahlSagonas2006`, InProceedings(|
      % https://it.uu.se/research/group/hipe/papers/succ_types.pdf
      author = {| Tobias Lindahl | Konstantinos Sagonas |};
      title = {Practical type inference based on success typings};
      booktitle = {
        Proceedings of the 8th ACM SIGPLAN International Conference on
        Principles and Practice of Declarative Programming};
      series = Some({PPDP’06});
      volume = None;
      number = None;
      pages = (167, 178);
      year = 2006;
    |));
    (`Caramel`, WebSite(|
      author = {| Leandro Ostera et al. |};
      title = {Caramel};
      url = `https://github.com/AbstractMachinesLab/caramel`;
      year = 2020;
    |));
    (`Hamler`, WebSite(|
      author = {| Feng Lee et al. |};
      title = {Hamler};
      url = `https://github.com/hamler-lang/hamler`;
      year = 2019;
    |));
    (`Ohori1995`, Article(|
      author = {| Atsushi Ohori |};
      title = {A polymorphic record calculus and its compilation};
      journal = {ACM Transactions on Programming Languages and Systems};
      volume = Some(17);
      number = Some({6});
      pages = (844, 895);
      year = 1995;
    |));
    (`Alpaca`, WebSite(|
      author = {| Jeremy Pierre et al. |};
      title = {Alpaca};
      url = `https://github.com/alpaca-lang/alpaca`;
      year = 2016;
    |));
    (`Gleam`, WebSite(|
      author = {| Louis Pilfold et al. |};
      title = {Gleam};
      url = `https://github.com/gleam-lang/gleam`;
      year = 2018;
    |));
    (`RossbergRussoDreyer2014`, Article(|
      author = {| Andreas Rossberg | Claudio Russo | Derek Dreyer |};
      title = {F-ing modules};
      journal = {Journal of Functional Programming};
      volume = Some(24);
      number = Some({5});
      pages = (529, 607);
      year = 2014;
    |));
    (`SvenssonFredlundEarle2010`, InProceedings(|
      title = {A unified semantics for future Erlang};
      author = {| Hans Svensson | Lars-Åke Fredlund | Clara Benac Earle |};
      booktitle = {Erlang ’10};
      series = None;
      volume = None;
      number = None;
      pages = (23, 31);
      year = 2010;
    |));
  ]

  let article = '<
    +chapter ?:(`gfn-article`)(|
        bibliography  = bibliography;
        title         = {自作言語でオンライン対局ゲームを実装した話};
        author        = {gfn};
        title-for-toc = None;
        subtitle      = None;
    |)<
      +section{はじめに}<
        +p{
          \dfn{Sesterl}（セスタール）という自作言語で\dfn{天九Online}というオンラインゲームを実装した話を報告したいと思います．
          Sesterlは2020年4月頃から筆者が開発している計算機言語で，
          簡単に言えば\dfn{Erlang}という既存の計算機言語に静的な型システムを搭載することを目的としているものです．
          要するに，JavaScriptに対するTypeScript，PureScript，Elm，ReScriptといった立ち位置の言語を
          Erlangに関して実装しようという試みであり，AltJSになぞらえて言えば
          AltErlangという具合の言語です．
          Erlangは\dfn{アクターモデル} \cite[`HewittBishopSteiger1973`];に基づいた意味論をもち，
          並行処理や分散処理に関する機能がビルトインで提供されているなど
          並行並列に特に強みをもつ言語ですが，静的に型がつかず\footnote{
            一応\dfn{success typing} \cite[`LindahlSagonas2006`];という型システム
            およびその型検査器の実装である\dfn{Dialyzer}がありますが，
            後づけで導入されたものであって健全性 (soundness) を満たすことを志向した型システムではなく，
            型がつくことによって保証できるプログラムの性質はかなり弱い主張に留まっており，
            型検査に通っても実行時に形式の不整合でエラーが起きることはごく普通にあります．
          }，実装の正しさを保証したりリファクタリングを施したりするのにかなり苦労する言語です．
          これを解決することを企図して開発しているのがSesterlというわけです．
        }
        +p{
          後々もう少し詳細に触れますが，Sesterlの型システムの概要を言うと，以下のようなものが備わっています：

          \listing?:(true){
            * \dfn{Damas–Milner多相}（いわゆるlet多相）およびその\dfn{Hindley–Milner型推論}
            * \dfn{列多相}によるレコード型 \cite[`GasterJones1996`];
            * 函数のラベルつき必須引数，および列多相を利用したラベルつきオプション引数
            * \dfn{F-ing Modules} \cite[`RossbergRussoDreyer2014`];に基づく，ファンクタなどを扱えるモジュールシステム
              ** このモジュールシステムは特に `gen_server` や `supervisor` といった\dfn{OTPライブラリ}を型安全に
                 ラップするのに利用しています．
            * 純粋な計算と並行処理とを区別するためのモナド
            * Erlangで実装した函数に型註釈をつけてSesterl側で使えるようにするFFI
          }%
        }
        +p{
          1年ほど開発を続け，Sesterlも或る程度成熟してきたのですが，
          「そうはいっても本当に実用に堪えるものになっているだろうか」という疑問が湧き，
          また丁度数年前からいつか実装したいと思っていたゲームがあったので，
          2021年5月末頃からSesterlを用いて実際に稼働するオンラインゲームのサーバサイドを実装してみることにしました．
          そうして（不足を感じたら適宜Sesterlの方も拡張しつつ）ひとまず動作するようになったのが天九Onlineというゲームです．
          天九Onlineは\dfn{天九}または\dfn{打天九}という中華圏で古くから遊ばれている既存の卓上ゲームを実装したもので，
          これは\dfn{天九牌}という32枚1セットの牌を使ったトリックテイキングゲーム\footnote{
            概して次のような性質を満たすルールのゲームを\dfn{トリックテイキングゲーム}と言います：

            \listing{
              * 1ゲームが複数の\dfn{トリック}という小さい勝負からなる．
              * 最初はプレイヤー全員に同じ枚数の手札が渡されている．
              * 各トリックでは，最初の手番の人から順に各プレイヤーが1回ずつ手札から場に札を出し，
                全員分出揃ったらその出揃ったカードに基づいてそのトリックの勝敗を決める．
                勝った人が次のトリックの最初の手番となる．
              * トリックで場に出たカードのうちどれが勝つかの判定基準は，
                最初の手番のプレイヤーが出した札である\dfn{台札}によって変わる．
              * 最後のトリックが終わったら，
                それまでの各トリックでの勝敗などをもとに何らかの条件でゲーム全体の勝敗や得点の移動を決める．
            }%

            いわゆるトランプを使って遊ぶトリックテイキングゲームの例としては\dfn{ハーツ}や\dfn{ナポレオン}などが有名です．
          }です．
          天九のルールについても簡単に紹介しつつ，実際に卓上ゲームが対戦できる小さいサーバをどのように設計・実装したか紹介します．
        }
        +p{
          趣味で言語処理系を実装する方は世の中に数多くいらっしゃると思いますが，
          大方の自作言語は制作者自身の言語処理系への理解のために創られたものであったりして，
          実用可能な水準まで作り込む経験談はあまり見かけないように思います．
          実用を目的としてドッグフーディングで自作言語を作り込むのはチマチマとした改善を継続する地味ながら執念を要する開発ですが，
          実際に自作言語のおかげで（そうでない場合よりも）高い生産性を発揮できていることが実感できたときの欣快はひとしおです．
          そんなわけで，ちょっと自己満足的な側面も含んでしまいますが，
          自作言語を実用してゲームを実装しつつ言語もドッグフーディングで改善していった過程を簡単に共有できればと思い，記事にしました．
        }
        +subsection{想定する前提知識}<
          +listing{
            * 静的型つきの函数型プログラミングに関する基礎的な理解．
              ** 例えばHaskellやOCamlでプログラムを書いたことがある，単純型の型つけ規則を眺めたことがあるなど．
            * Webアプリケーションの仕組みに対する基礎的な理解．
              ** クライアント-サーバモデルという概念やHTTPの規格の概要を把握しているなど．
          }
        >
      >
      +section{Erlangの簡単な解説}<
        +p{
          SesterlはErlangという既存の言語をラップするために開発されました．
          では元々のErlangとはどんな言語なのでしょうか？\quad;
          おそらく「Erlangという名前くらいは聞いたことがあるが使ったことは全くない」という読者も多いかと思うので，
          簡単にErlangの構文や意味論について説明します．
          とはいえErlangに入門するための文書は公式ドキュメントはもとより非公式のものもいくらでもあるはずなので，
          ここで懇切丁寧に解説するつもりはなく，
          全く読み書きしたことのない人に最低限おおよそどんな言語なのかの雰囲気を掴んでもらうために
          ごく簡単にかいつまんで記載します．
        }
        +subsection{基本的な構文と意味論}<
          +subsubsection{モジュールと函数の定義}<
            +p{
              前述の通り，Erlangの意味論はいわゆる函数型言語のそれを基調としており，
              例えば階乗函数 `fact` や整数のリストを受け取りその総和を返す函数 `sum` は以下のように書けます：

              \d-code(```
                -module(calc).
                -export([fact/1, sum/1]).

                fact(N) ->
                    case N =< 1 of
                        true  -> 1;
                        false -> N * fact(N - 1)
                    end.

                sum(Ns) ->
                    lists:foldl(fun(N, Acc) -> N + Acc end, 0, Ns).
              ```);%

              変数の名前は大文字始まり，トップレべルで定義される函数の名前は小文字始まり\footnote{
                トップレベルの函数の名前は正確には後述のアトムの形式と一致し，単引用符で括って一般の文字列が名前として使えます．
              }，函数定義の終わりにはピリオドを打つ，
              `case` 式によるパターンマッチングは枝の区切りにセミコロンを使う，
              他のモジュールの函数を呼び出すには `lists:foldl` などとモジュール名と函数名をコロンで繋いで書くなど
              かなりアクの強いProlog風の具象構文をもっていますが，
              Lisp諸方言，Haskell，OCamlあたりに親しみのある方なら
              函数定義についてはわりと構文から意図するところが推測できるのではないかと思います．
            }
            +p{
              Erlangではモジュールが入れ子にできたりはせず，全てのモジュールが平坦に1つの名前空間に並び，
              1つのソースファイルが1つのモジュールの定義を担います．
              上記の例の1行目はこのソースファイルが記述するモジュールの名前を，
              2行目はソースファイル内で定義されている函数のうちどれを公開するか
              （＝モジュール外から呼び出せるようにするか）を記載しています．
              `fact/1` が階乗函数の名前で，`/1` はアリティ（＝何個の引数をとるか）を表します．
              アリティが名前の一部なのは，函数が（HaskellやOCamlなどと違い）Curry化されておらずアリティをもち，
              かつ同一の名前で異なるアリティの函数は全く別の（たまたま名前が同じ）函数として扱うことを許す言語設計になっているためです．
              特に，アリティの異なる補助函数は同名にする慣習があり，
              上記の `fact/1` を末尾呼び出し再帰になるように書き換えるときには以下のように
              補助函数を `fact/2` としたりします：

              \d-code(```
                fact(N) ->
                    fact(1, N).

                fact(Acc, N) ->
                    case N =< 1 of
                        true  -> Acc;
                        false -> fact(Acc * N, N - 1)
                    end.
              ```);%

              なお，パターンマッチングやそれによる分岐は函数の引数でも行なえて，
              また `when` 節によりマッチする条件を加えることができる\footnote{
                ただし，`when` 節の中では限られた組み込み函数しか使えないように制限されています．
                これは `when` 節の評価中に或る種の “副作用” が発生しないことを保証するためのようです．
              }ので，`fact/1` はさらに以下のような小慣れた実装に書き換えることができます：

              \d-code(```
                fact(N) -> fact(1, N).

                fact(Acc, N) when N =< 1 -> Acc;
                fact(Acc, N)             -> fact(Acc * N, N - 1).
              ```);%

              こうして定義した `fact/1` は，モジュール外から使うときは以下のように呼び出します：

              \d-code(```
                -module(some_external_module).
                -export([main/0]).

                main() -> calc:fact(6).
              ```);%
            }
          >
          +subsubsection{局所束縛}<
            +p{
              局所的な変数の束縛は少し独特で，以下のように書きます：

              \d-code(```
                distance({X1, Y1}, {X2, Y2}) ->
                    XDiff = X1 - X2,
                    YDiff = Y1 - Y2,
                    math:sqrt(XDiff * XDiff + YDiff * YDiff).
              ```);%

              変数だけでなく一般のパターンも左辺に書くことができます
              （ただし，パターンについては少し注意すべきことがあるので後述のパターンマッチングの節を参照してください）：

              \d-code(```
                distance(Pos1, Pos2) ->
                    {X1, Y1} = Pos1,
                    {X2, Y2} = Pos2,
                    XDiff = X1 - X2,
                    YDiff = Y1 - Y2,
                    math:sqrt(XDiff * XDiff + YDiff * YDiff).
              ```);%

              函数も束縛でき，呼び出しはグローバルに定義された函数と同様に書けます：

              \d-code(```
                sum(Ns) ->
                    F = fun(N, Acc) -> N + Acc end,
                    lists:foldl(F, 0, Ns).
              ```);%

              ちなみに，グローバルに定義された函数も単独で函数抽象として使えます：

              \d-code(```
                G = fun lists:foldl/3,
              ```);%
            }
          >
          +subsubsection{文字列とバイナリ}<
            +p{
              Erlangに於ける文字列の扱いは少し特殊で，まず通常の二重引用符で括られた文字列は
              （Haskellの `String` が `[Char]` に等しいのと似て）単に “コードポイントのリスト” です．
              例えば `"hello"` と書いた場合，これは `[104, 101, 108, 108, 111]` と全く等価です．
              一方で `<<"hello">>` とさらに二重三角括弧で括って定数を書いた場合，
              これは “エンコード済みのバイト列としての文字列” を表します．
              こちらが多くの計算機言語で「文字列」と言った時に指すものにより近い値で，
              このような形式をErlangでは\dfn{バイナリ} (binary) と呼んでいます．
              これはこの形式がテキストに限らず一般のバイト列を格納する形式であるためで，
              「バイナリファイル」と言う時の「バイナリ」と同じ気持ちでの命名だろうと思います．
            }
          >
          +subsubsection{マップ（辞書，連想配列）}<
            +p{
              Erlangには\dfn{マップ} (map) という一般に辞書とか連想配列とも呼ばれる表引き用の機能があり，
              以下のように
              \no-break-latin{`#{`${k_1} `=>` ${v_1}`,` ${\ldots}`,`${k_n} `=>` ${v_n}`}`}
              という形で記述します：

              \d-code(```
                Map = #{<<"太郎">> => 110, <<"敏子">> => 95},
              ```);%

              取り出しや更新は `maps` モジュールの函数によって行なったり，
              パターンマッチングによって行なったりします（詳細は省略）．
              キーの等価性判定は組み込みの等価演算 `=:=` によっており，
              OCamlでのファンクタ `Map.Make` の引数に実装を与えたりして弄るようなことはできません．
            }
          >
          +subsubsection{アトム}<
            +p{
              Erlangには\dfn{アトム} (atom) というRubyに於けるシンボルとよく似た機能があります．
              すなわち，“一定の決まった文字列で表される定数” です．
              これは小文字始まりの `foo` とか `bar` といった文字列のトークンで，
              特にどこかで定義せずともソースコード中でいきなり使えます．
              OCamlの多相バリアントを引数が取れないように制限したものと捉えてもよいかもしれません．
              また，小文字始まりでなくても，`'Capitalized'` とか `'@foo'` のように
              単引用符で括ることでより一般の文字列をアトムにできます．
            }
            +p{
              アトムの典型的な用例は，タプルと組み合わせて代数的データ型のように使うものです．
              例えばキーでマップを表引きする函数 `maps:find/2` は，対応する値 ${v} が見つかった場合は
              \no-break-latin{`{ok,` ${v}`}`} を，
              見つからなかった場合は `error` をそれぞれ戻り値として返します．
              すなわち，OCamlでいえば前者が `Some` ${v}，後者が `None` に相当する表現なわけです．
            }
            +p{
              Erlangでは色々なものが実はアトムとして定式化されており，例えば以下はいずれもアトムです：

              \listing{
                * 真偽値，すなわち `true` と `false`．
                  ** これらは “真偽値専用の値” ではなく，“そういう文字列のアトム” にすぎない．
                * モジュール名．
                * （アリティを除いた）函数名．
              }%

              したがって，（実装がスパゲティ化するおそれと隣合わせなので乱用には注意すべきですが）
              実は函数呼び出しも以下のように書けたりします：

              \d-code(```
                ModName = math,
                FunName = sqrt,
                ModName:FunName(2).
              ```);%
            }
          >
          +subsubsection{パターンマッチング}<
            +p{
              既にちらっと登場しましたが，パターンマッチングは `case` 式によって行ないます：

              \d-code(```
                tree_size(Tree) ->
                    case Tree of
                        empty                -> 0;
                        {node, Tree1, Tree2} -> 1 + tree_size(Tree1) + tree_size(Tree2)
                    end.
              ```);%

              パターンはHaskellやOCamlに慣れている方にとっては大方想像通りで，`_` がワイルドカードなのも同じです．
            }
            +p{
              ただし，1つだけかなり意外な落とし穴があります：\quad;
              既に束縛されている変数をパターン中で使った場合はその変数が束縛されている値を書いたのと同じ扱いになります．
              例えば，以下の定義に基づくと `f()` は `false` に評価されます：

              \d-code(```
                f() ->
                    X = 42,
                    case 57 of
                        X -> true;
                        _ -> false
                    end.
              ```);%

              実は通常の局所束縛も左辺がパターンなので同じことが言えて，
              次の定義に基づくと `g()` の評価は3行目で「`57` が `42` というパターンにマッチしない」という失敗が起き
              例外が送出されます：

              \d-code(```
                main() ->
                    X = 42,
                    X = 57,
                    X.
              ```);%

              ここからの帰結として，同じスコープでは同名の変数を複数回束縛することができません．
              それゆえにErlangコードでは以下のようなちょっとマヌケな連番の変数名をよく見かけることがあります：

              \d-code(```
                update_state(SomeParameter, State0) ->
                    State1 = run_first_update_process(State0),
                    State2 = run_second_update_process(State1),
                    …
                    State5.
              ```);%

              もし筆者がErlangの言語設計を与える立場だったなら束縛済みの変数を値として使うパターンは
              単に `X` などと書くのではなく `val X` などと書くような構文を採用して
              同じ変数名を複数回束縛できるようにしたいと考えただろうなとよく思いますが，
              まあそんなことを言っても実際のErlangはそうはなっていないので気をつけて従うしかないですね．
              そもそもなぜこんな仕組みがあるのかというと，後に出てくる `make_ref/0` などの機構で
              動的に決まる “トークン” 的な値にマッチさせたいことがよくあって，それに利用したいからだろうと思います．
            }
          >
          +subsubsection{spec註釈}<
            +p{
              Erlangにも健全性を満たさない体系ながらsuccess typingという型システムがあり，
              これを実装したDialyzerという型検査器があります．
              このDialyzer向けに，或いは人間が直接読むために，大域的に定義された函数には
              “どんな形式の引数がくることを想定していて，どんな形式の戻り値を返すのか”
              ということを表した\dfn{spec註釈}というものを書くことができます．
              spec註釈は以下のように記述します：

              \d-code(```
                -type point() :: {integer(), integer()}.

                -spec distance(point(), point()) -> float().
                distance({X1, Y1}, {X2, Y2}) ->
                    XDiff = X1 - X2,
                    YDiff = Y1 - Y2,
                    math:sqrt(XDiff * XDiff + YDiff * YDiff).
              ```);%

              アリティが 0 でも型名には `()` がつきます．これは以下で触れるようなspec註釈中のアトムと区別するためです．
              Dialyzerはこの註釈と実際の函数の定義に明らかな不整合がないかを検査します．
              spec註釈にはもう少しいろいろなことを表す記法があります：

              \listing{
                * `term()` で任意の形式を表す（いわゆるTop型）．

                * \no-break-latin{`{`${T_1}`,` ${\ldots}`,` ${T_n}`}`} で直積型を表す．

                * `foo` などのアトムで “そのアトム単独のリテラル型” を表す．

                * \no-break-latin{${T_1} `|` ${\cdots} `|` ${T_n}} で合併型を表す．
                  ** 例えば `boolean()` は `true | false` と等しい．
                  ** いわゆるresultやeitherは
                     \no-break-latin{`{ok,` ${T_1}`} | {error,` ${T_2}`}`}
                     で表されることが多い．

                * `when` を用いて同じ形式の部分にローカルに名前を与えて括り出すことができる：

                  \d-code(```
                    -spec distance(Point, Point) -> float() when Point :: {integer(), integer()}.
                  ```);%

                * `{error, Reason :: term()}` のように，わかりやすさのために余剰な名前を加えることもできる．
                  この例は `{error, term()}` と全く同じ．
              }%

              他にも色々な記法や組み込みで定義された型がありますが，ここでは上記程度の内容で済ませることにします
              （以降の記事中でも少ししか使いません）．
            }
          >
        >
        +subsection{並行処理の定式化}<
          +p{
            前述の通り，
            Erlangは並行処理や分散による並列処理を得意とする計算機言語で，
            特に並行や分散の処理は組み込み函数や専用の制御構文といった言語機能としてサポートされているのが特徴です．
            Erlangに於ける並行処理は\dfn{アクターモデル} (actor model) \cite[`HewittBishopSteiger1973`];という
            定式化に基づいたもので\footnote{
              ただし，Erlangの言語設計を行なったJoe Armstrongらは特にアクターモデルという概念を把握していたわけではなく，
              結果的に似た定式化になったというのが史実だそうです．
              このことを指して逸話的に「良い設計は何度も再発見される」と言う人もいたりします．
            }，これは以下のような特徴をもちます：

            \listing?:(true){
              * 計算は\dfn{プロセス}と呼ばれる互いにメモリを共有しない単位が複数個並行して
                各々に与えられた式を評価することによって行なわれる．

                ** この「プロセス」はOSレベルのプロセスとは関係のない概念であることに注意．

              * 各プロセスは\dfn{プロセスID}或いは略して\dfn{PID}と呼ばれる固有のIDをもち，
                或るプロセスが別のプロセスにメッセージを送る時の宛先などとして使われる．
                処理を走らせているプロセス自身のPIDは `self()` という組み込みの函数の適用を評価すると取得できる．

              * 新たにプロセスを生成する処理は基本的には `spawn/1` という組み込みの函数によって行なわれる．
                \no-break-latin{`spawn(fun() ->` ${e} `end)`}
                が評価されることで新たなプロセスが生成され，そのプロセスが式 ${e} の評価を始める．
                呼び出した側のプロセスには，新たに生成されたプロセスのPIDが即座に戻り値として返る．

              * 或るプロセスが別のプロセスにメッセージを送る処理は，その送り先のPIDを表す式を ${e_{\mathrm{pid}}}，
                メッセージとして送りたい値を表す式を ${e_{\mathrm{msg}}} とすると，
                \no-break-latin{${e_{\mathrm{pid}}} ! ${e_{\mathrm{msg}}}}
                という式を評価することで実行される．
                この式全体の戻り値としては即座に ${e_{\mathrm{msg}}} の評価結果であるメッセージの値が返り，
                送信は相手の受信を待つなどせずに完了する．すなわち，送信は非同期的である．

              * 各プロセスは，自分宛てに送られてきたメッセージを自身の\dfn{メールボックス} (mailbox)という機構に届いた順に蓄える．
                この処理は “プログラム側からは見えないうちに” 行なわれている．

              * 受信処理の機能としては
                \no-break-latin{`receive` ${p_1} `->` ${e_1}`;` ${\ldots}`;` ${p_n} `->` ${e_n} `end`}
                という専用の構文があり，
                プロセスは評価中にこの式に出会うと自身のメールボックスに溜まった値の列 ${v_1, \ldots, v_m} を見て
                まず最初に届いていた ${v_1} について ${p_1, \ldots, p_n} のいずれかのパターンと
                （`case` 式のように）マッチするかどうか確かめる．
                ${p_i} とマッチしたら，その中の変数を束縛して，${e_i} の評価に移る．
                どれともマッチしなかったら，${v_1} はメールボックスの中に先頭位置で残したまま，
                次に ${v_2} が ${p_1, \ldots, p_n} のいずれかとマッチするか同様に確かめ，
                ${p_i} とマッチしたらやはり対応する ${e_i} を評価する．
                最後の ${v_m} もマッチしなかったらプロセスは待機することにし，
                以後新しいメッセージが届くごとに同様のことを行なう．

                ** ただし，この仕組みだけだと何らかの理由で期待するメッセージが一向に届かないときに
                   `receive` 式で永久に待機してしまうおそれがあるので，そういう状況が望ましくない場合は
                   \no-break-latin{`after` ${e_{\mathrm{duration}}} `->` ${e_{\mathrm{otherwise}}}} という枝を
                   `receive` 式の分岐のひとつとして設けることができる．
                   ${e_{\mathrm{duration}}} はタイムアウトを表すミリ秒単位の整数で，
                   この分岐は `receive` で待機し始めてから ${e_{\mathrm{duration}}} ミリ秒経っても
                   他のパターンにマッチするメッセージがひとつも来なかった場合は ${e_{\mathrm{otherwise}}} の評価に移行する，
                   という仕組みを提供する．


              * プロセスは，自身の式 ${e} の評価が終わる（か評価途中で捕捉されない例外が送出されるかする）と消える．
                消えたプロセスに向かって `!` で送信した場合は，単に何も起こらない．
            }
          }
          +p{
            複数プロセスが並行に走る簡単な例を見てみます：

            \d-code(```
              -module(concurrency_example).
              -export([main/0]).

              sub() ->
                  receive
                      {From, N} ->
                          Answer = moduleB:calculationB(N),
                          From ! Answer
                  end.

              main() ->
                  PidA = self(),
                  PidB = spawn(fun() -> sub(PidA) end),
                  PidB ! {PidA, 42},
                  ResultA = moduleA:calculationA(57),
                  receive
                      ResultB -> {ResultA, ResultB}
                  end.
            ```);%

            或るプロセス A で `concurrency_example:main()` が呼び出されて処理が開始する想定の実装です．
            このプログラムでは，まず `PidA` を呼び出したプロセスのPIDに束縛し，
            続いて新しいプロセス B を生成して `PidB` をその新しいプロセスのPIDに束縛します．
            起動されたプロセス B では `sub/1` が A のPIDに適用され，`receive` 式を評価するところで待機します．
            プロセス A は B に向かって返信用の自身のPIDと `42` という整数の組を送ります．
            B はそれを受け取って `From` を A のPIDに，`N` を `42` に束縛し，
            `moduleB:calculationB(42)` を評価します．
            その間に A は `moduleA:calculationA(57)` を評価します．
            B は計算が終わったらその結果を `From ! Answer` で A に送り返して終了します．
            A も計算が終わったら自分のメールボックスを見て B からの返信が届いているかを確認し，
            届いていたら（或いは待機して届いたら）`ResultB` にその結果を束縛し，
            最終結果の `{ResultA, ResultB}` を `main()` の戻り値とします．
            要するに，プロセス A が `moduleA:calculationA(57)` を，
            プロセス B が `moduleB:calculationB(42)` をそれぞれ並行して処理するような実装になっているわけです．
            この並行処理の動作の様子をシーケンス図に描き起こすと以下のような具合です\footnote{
              メッセージがメールボックスに入るタイミングと
              メールボックスに入っていたメッセージが `receive` 式によって取り出されるタイミングは一般には異なるので
              図はやや不正確ですが，おおよその直観を汲み取っていただけると幸いです．
            }：
          }
          +image(10cm)(6cm)(fun ctx (x, y) -> (
            let xA = x +' 1cm in
            let xB = x +' 8cm in
            let yA1 = y +' 5cm in
            let yA2 = y +' 0.5cm in
            let yB1 = y +' 4cm in
            let yB2 = y +' 1cm in
            let txt pos it = [ draw-text pos (read-inline ctx it) ] in
            let darr = Gr.dashed-arrow 1pt (5pt, 3pt, 0pt) Color.black 12pt 10pt 3pt in
            let arr = Gr.arrow 1pt Color.black 12pt 10pt 3pt in
            List.concat [
              [
                draw-text (xA -' 0.75cm, yA1 +' 0.25cm) (read-inline ctx {プロセス A});
                stroke 1pt Color.black (Gr.line (xA, yA1) (xA, y));

                draw-text (xB -' 0.75cm, yB1 +' 0.25cm) (read-inline ctx {プロセス B});
                stroke 1pt Color.black (Gr.line (xB, yB1) (xB, yB2));
              ];

              txt (xA +' 1cm, yA1 -' 0.4cm) {`spawn`};
              darr (xA, yA1 -' 0.5cm) (xB, yB1);

              txt (xA +' 1cm, yA1 -' 1.4cm) {`{`AのPID`, 42}` の送信};
              txt (xA -' 0.3cm, yA1 -' 1.6cm) {`!`};
              arr (xA, yA1 -' 1.5cm) (xB, yB1 -' 1cm);
              txt (xB +' 0.2cm, yB1 -' 1.1cm) {`receive`};

              txt (xB +' 0.2cm, yB2 +' 1.2cm) {`moduleB:calculationB`};

              txt (xA +' 0.2cm, yA2 +' 1.9cm) {`moduleA:calculationA`};

              txt (xA +' 2.5cm, y +' 0.75cm) {計算結果の送信};
              txt (xB +' 0.2cm, yB2 +' 0.4cm) {`!`};
              arr (xB, yB2 +' 0.5cm) (xA, yA2 +' 0.5cm);
              txt (xA -' 1.5cm, yA2 +' 0.4cm) {`receive`};

              txt (xB -' 0.3cm, yB2 -' 0.4cm) {終了};
            ]
          ));
        >
        +subsection{OTP Design Principlesについて}<
          +p{
            並行処理がどのように実現されているかは前節で紹介しましたが，
            実際には逐一 `spawn`，`!`，`receive` といった比較的低級な送受信の実装を直接記述する必要はあまりなく，
            \dfn{OTP}（\dfn{Open Telecom Platform}）と呼ばれるライブラリ群を使って並行処理を実現することが多いです．
            OTPは並行処理，とりわけ可用性の追求を見越した並行処理に於いて共通の典型的なパターンを抽出したライブラリで，
            その中でも `gen_server` モジュールと `supervisor` モジュールを利用することがほとんどです．
          }
          +subsubsection{`gen_server` モジュール}<
            +p{
              並行処理のプログラムを書くと，
              “状態を保持して長期間存在し，適宜外部とやり取りして状態を更新したり，外部から状態の一部を取得されたりするプロセス”
              というパターンがとても多いことに気づきます．というかこのパターンに収まらない例が珍しいくらいかもしれません．
              このパターンにあてはまるプロセスとして，状態として唯一つ整数を保持し，
              外部から整数が取得されたり更新されたりするもの（以下では\dfn{セルプロセス}と呼ぶことにします）を扱うことを考え，
              それを `cell` という以下のようなAPIのモジュールとして実装することを考えます：

              \listing{
                * `-spec start(integer()) -> pid().`
                  ** 初期状態を与えてセルプロセスを起動し，そのPIDを返す．
                * `-spec get(pid()) -> integer().`
                  ** セルプロセスが現在保持している整数を取得する．
                  ** これはセルプロセスからの返信が必要な処理なので返信が来るまで待つ．
                     既にセルプロセスが存在しない場合や，5秒経っても返信がない場合は例外送出とする．
                * `-spec set(pid(), integer()) -> ok.`
                  ** セルプロセスが保持する整数を更新する．
                  ** これは指示を出すだけで返信が要らないので送信側はブロックされず，即座に戻り値の `ok` が返る．
                * `-spec stop(pid()) -> ok.`
                  ** セルプロセスを終了させる．
              }%

              これを実装したのが以下のようなものです（コード中の `make_ref/0` は初出ですが，後ほど説明します．
              `throw/1` は詳しくは説明しませんが例外送出です）：

              \d-code(```
                -module(cell).
                -export([start/1, get/1, set/2, stop/1]).

                start(N) ->
                    spawn(fun() -> loop(N) end).

                get(Pid) ->
                    Tag = make_ref(),
                    Pid ! {get, self(), Tag},
                    receive
                        {got, Tag, N} -> N
                    after 5000 ->
                        throw({failed_to_get, Pid})
                    end.

                set(Pid, N) ->
                    _ = Pid ! {set, N},
                    ok.

                stop(Pid) ->
                    Pid ! stop.

                loop(N) ->
                    receive
                        {get, From, Tag} ->
                            From ! {got, Tag, N},
                            loop(N);
                        {set, M} ->
                            loop(M);
                        stop ->
                            ok
                    end.
              ```);%

              `loop/1` がセルプロセスで稼働する処理で，その引数がセルプロセスの保持している状態にあたります．
              セルプロセスはこの函数の `receive` で外部からのメッセージの到達を待機し，
              メッセージを受け取ったら以下のように対処して，
              （終了する場合以外は）`loop/1` を再帰的に呼び出して再び待機状態に戻ります：

              \listing?:(true){
                * 受け取ったメッセージが `{get, From, Tag}` という “リクエスト” だった場合，
                  現在保持している整数 `N` を使って `{got, Tag, N}` という “レスポンス” を送信元に返す．

                  ** ここで `Tag` は “リクエスト” と “レスポンス” を紐づけるために使っている “トークン” で，
                     `make_ref/0` は呼び出しのたびにこのような “トークン” をフレッシュに生成する組み込みの函数です．

                * 受け取ったメッセージが `{set, M}` だった場合，
                  保持していた整数を捨てて新たに `M` を保持するようにする．

                * 受け取ったメッセージが `stop` だった場合，直ちに終了する．
              }%
              `get/1`，`set/2`，`stop/1` はそれぞれ `{get, From, Tag}`，`{set, M}`，`stop` のメッセージを
              セルプロセスに送るものとして実装されており，他のプロセスで呼び出すことで該当のセルプロセスとやり取りすることができます．
              このうち特に `get/1` はセルプロセスからの “レスポンス” を `{got, Tag, N}` のパターンで受け取るようになっており，
              この `Tag` は束縛済みの変数なので変数パターンではなく値としてマッチすることに注意してください．
              これにより他のたまたま同じ形式のメッセージが届いていても該当の “リクエスト” と対応する “レスポンス” だけを
              メールボックスから取り出すことができます．
            }
            +p{
              こうした挙動を記述したい場面はとても多く，OTPライブラリは
              このような実装のパターンを一般化して記述するための仕組みとして `gen_server` を提供しています．
              `gen_server` は，端的に言えば “受け取ったメッセージに対してどう対処するかだけ与えれば上記の
              `loop` や `start` などに相当する機能（を大幅に拡張したもの）を担ってくれる” モジュールです．
              まず，モジュールを “`gen_server` に準拠した実装” にするために，
              “受け取ったメッセージに対してどう対処するか” などに相当する以下の5つの函数を定義します：

              \listing{
                * `-spec init(InitArg) → {ok, State} |` ${\ldots}`.`
                  ** 生成されたプロセスが起動直後に行なう処理．
                     少し後に紹介する \no-break-latin{`gen_server:start`} や
                     \no-break-latin{`gen_server:start_link`} に与えられた
                     引数 `InitArg` を受け取り，初期状態 `State` をつくって
                     `{ok, State}` を返す．

                * `-spec handle_call(State, From, CallMsg) -> {reply, Reply, State} |` ${\ldots}`.`
                  ** 後述する `gen_server:call` によって送信されてきた，返信が必要なメッセージを受信したときに行なう処理．
                     返信内容を `Reply`，更新した状態を `State` として，
                     `{reply, Reply, State}` を返す．

                * `-spec handle_cast(State, CastMsg) -> {noreply, State} | {stop, Reason} | ` ${\ldots}`.`
                  ** 後述する `gen_server:cast` によって非同期的に送信されてきた，返信不要のメッセージを受信したときに行なう処理．
                     更新した状態を `State` として `{noreply, State}` を返す．
                     メッセージをうけて停止する場合はやはり `{stop, Reason}` を返す．

                * `-spec handle_info(State, Info) -> {noreply, State} | {stop, Reason} |` ${\ldots}`.`
                  ** `handle_cast` とほぼ同じだが，`gen_server:cast` によって送信されたものではない
                     （`!` によって送信されてきたものなど）その他のメッセージをさばく処理．
                     後述する\dfn{モニタ}による \no-break-latin{`{'DOWN',` ${\ldots}`}`} の形式の
                     メッセージを受け取ったりするのに使う．

                * `-spec terminate(State, Reason) -> ok.`
                  ** 終了することが確定したとき，終了直前に呼び出される処理．
                     基本的には何もせず `ok` を返すのでよい．
              }%

              これらの函数を定義したモジュール ${X} がある下で，
              \no-break-latin{`gen_server:start(`${X}`,` ${e_{\mathrm{InitArg}}}`, [])`}
              を呼び出すと，上記の函数を使用したプロセスを立ち上げることができます\footnote{
                `gen_server:start/3` の第3引数には起動オプションを渡すのですが，大抵は空リストで問題ありません．
              }．大抵の場合はこの `gen_server:start/3` も同一モジュールに含めてしまい，
              `InitArg` の形式やモジュール名などをモジュール内に隠蔽します．
              モジュール内でそのモジュールの名前を指すには陽に書かずとも `?MODULE` というマクロが使えるので，
              殆どの場合は以下のような要領の函数がモジュール内に定義されます：

              \d-code(```
                start(...) -> gen_server:start(?MODULE, ..., []).
              ```);%

              なお，\no-break-latin{`-module(`${X}`).`} の直後に
              \no-break-latin{`-behavior(gen_server).`} と追記することで
              “`gen_server` に適合させる” のに必要な
              `init/1` や `handle_call/3` など上記5つの函数が揃っているかコンパイル時に検査してくれます．
              こうした “函数を要求する機構” を\dfn{ビヘイビア} (behavior) といい，
              ビヘイビア ${B} が要求する函数を ${B} の\dfn{コールバック函数} (callback function) といいます．
              例えばこの節では `gen_server` ビヘイビアが `init/1` や `handle_call/3` といったコールバック函数を要求する
              ことを紹介しました．
            }
            +p{
              ビヘイビア ${B} が要求するコールバック函数を全て実装したモジュールを
              ${B} の\dfn{コールバックモジュール}といいます．
              セルプロセスを `gen_server` ビヘイビアのコールバックモジュールとして実装すると以下のようなプログラムになります：

              \d-code(```
                -module(cell).
                -behavior(gen_server).

                -spec start(integer()) -> pid().
                start(N) ->
                    {ok, Pid} = gen_server:start(?MODULE, N, []),
                    Pid.

                -spec get(pid()) -> integer().
                get(Pid) ->
                    {got, N} = gen_server:call(Pid, get),
                    N.

                -spec set(pid(), integer()) -> ok.
                set(Pid, M) ->
                    gen_server:cast(Pid, {set, M}).

                -spec stop(pid()) -> ok.
                stop(Pid) ->
                    gen_server:cast(Pid, stop).

                init(N) -> {ok, N}.

                handle_call(N, _, get) -> {reply, {got, N}, N}.

                handle_cast(N, {set, M}) -> {noreply, M};
                handle_cast(_, stop)     -> {stop, normal}.

                handle_info(N, _) -> {noreply, N}.

                terminate(_, _) -> ok.
              ```);%

              返信を要する同期的メッセージの形式 `CallMsg` が `get`，
              それに対する返信の形式 `Reply` が `{got, integer()}`，
              非同期的メッセージの形式 `CastMsg` が `{set, integer()} | stop` というわけです．
              \no-break-latin{`{stop, `${\ldots}`}`} に与えている終了理由の値 `normal` は正常終了を表すための値の1つです．
            }
            +p{
              もとが簡単な挙動のプロセスだったのであまり便利になった気がしないかもしれませんが，
              このような “メッセージを受け取って状態を更新するreducer” を与えさえすればプロセス生成や並行処理を全部担ってくれる
              `gen_server` による共通化には以下のような恩恵があります：

              \listing{
                * 個別に実装することによる不具合の発生を防ぎやすく，
                  プロセスが担う機能の複雑化に対して開発が相対的にスケールしやすい．
                * `gen_server` によってつくられるプロセスは
                  通常の `spawn` によって起動する “生のErlangの” プロセスに比べ種々の強化機能を備えたものになっており，
                  それにより次節で述べるOTP Design Principlesに準拠して異常終了をしていないかなどを監視することができる．
              }%
            }
          >
          +subsubsection{プロセス間の監視という概念}<
            +p{
              ここまでの説明では殆ど触れてきませんでしたが，ErlangおよびOTPは慣習的に
              「異常が起きたらプロセスごと死ぬようにし，それを監視している別のプロセスが異常終了を検知して
              場合によっては再起動し再処理を促す」
              という設計に便利なようにつくられています．これによって可用性の高いシステムの構築に貢献します．
            }
            +p{
              そもそもプロセスの異常終了（つまり意図しない終了）には以下のようなものがあります\footnote{
                BohrとHeisenbergからもじって，前者を\dfn{ボーアバグ} (Bohrbug)，
                後者を\dfn{ハイゼンバグ} (Heisenbug) と呼んだりします．
                ハイゼンバグは確率的なものとは限らずより広範に「再現しようとすると消える不具合」全般を指し，
                例えば「`printf` を挟むとなぜか消える不具合」などを含むこともあるようです．
              }：

              \listing{
                * 特定の状況で再現性がある意図しない挙動：
                  ** 特に並行性に関連しない，比較的単純な実装ミス．
                * 確率的に失敗し，必ずしも再現しない挙動：
                  ** 並行処理のスケジューリングに依存して稀に顕現する不具合．
                     すなわち，大抵は意図通り動くが，
                     実はデータ競合を起こす実装になっていて稀に意図していない挙動をする場合\footnote{
                       実はプロセス間でのメモリ共有がないErlangの意味論でもデータ競合は発生します．
                       典型的にはプロセスの開始や終了のタイミングに関してデータ競合が起きたりします．
                     }．
                  ** プログラムに問題はないが，マシンの性能の局所的悪化により
                     I/Oが詰まったり分散処理に失敗した場合．
              }%

              前者は単にテスト（やDialyzerの検査）によって発見することが想定されており，
              まあこれはErlang以外の大抵の言語で同様であろうと思います．
              Erlangが独特なのは後者に対する対処です．
              大抵の言語だとデータ競合は静的に起きないことを保証しようとしますし，
              おそらく計算機言語の理論家ならそういう言語設計を自然と志向するのではないかと思いますが，
              Erlangはそうではありません．
              Erlangでは「典型的には正しく動くが，確率的に稀に失敗する」という状況は
              “普通に起きるもの” として織り込み済みという世界観を取ります．
              そして，こうした可能性を静的に排除するという方針ではなく，
              「まあそういうこともたまにあるよね，
              そしてたまにしか起きないなら起きた場合ももう1, 2回やり直すうちにいずれうまくいくよね」
              とおおらかな気持ちで対処するような仕組みを構成しやすい言語設計になっています．
              なんだかむず痒い気持ちになると思いますが，
              “不具合は気づかないうちに混入してしまうのが当たり前であると想定しておいて次善の策を取りやすくしている”
              という点では一定の納得感のある方針です．
              また，（本稿では詳しくは触れませんが）Erlangでは重要な機能として並行処理のほかに並列分散処理があり，
              \dfn{ノード} (node) と呼ばれる単位で複数のサーバがネットワークで繋がり，
              それらの間でErlangの値を “じかに投げ合える” \dfn{クラスタ}を形成するようになっています．
              こちらは並行処理と違ってさらに相手ノードが障害で落ちた場合を考慮する必要があったり，
              ノード間の通信だと先に投げたメッセージが先に届くことを保証できなかったりと
              不確定要素が大きくなり，扱いがさらに難しくなりますから，
              “小さい不具合はあるものとして織り込み済み” という方針は
              なお一層の納得感があります\footnote{
                Erlangの開発は\dfn{Ericsson}というスウェーデンの通信機器メーカーによって
                1980年代に行なわれたもので，実際に電話交換機をErlangで実装するチームからの
                フィードバックによって迅速に言語設計が拡張されていたそうです．
                電話交換機を実装するためにできる限り分散してスケールするようにし，
                かつ通信を途絶えさせないために可用性を重視して
                不具合にも対処せねばならないことを念頭に置いて
                このような言語設計になったという点は
                バックグラウンドからも理解しやすいかと思います．
              }．
              ただし，「再起動して再処理すればいいよね」といっても
              稼働していたプロセスの状態を復元するのは
              一般には言語やOTPライブラリ側ではなくプログラムを書く側の責任範囲なので
              注意せねばなりません．すなわち，復元に真に必要なデータがある場合は
              より信頼性の高いメモリやストレージに永続化しておく必要があります\footnote{
                この目的のために使えるものとして，
                \dfn{ETS}および\dfn{DETS}というErlangのランタイムに内蔵された
                それぞれ揮発性・不揮発性のテーブルがあったりします．
              }．
              ともあれ，いずれにせよこうした考えにより
              ErlangおよびOTPでは「プロセスがプロセスを監視する」という概念が導入されているのです．
            }
          >
          +subsubsection{リンクとモニタ}<
            +p{
              前節でプロセス間には監視する・監視されるという関係があることを説明しましたが，
              それがどのように言語機能およびOTPライブラリで定式化されているのかを紹介します．
              まず，言語機能としての監視にまつわる関係には以下の2種類があります：

              \listing{
                * \dfn{リンク} (link)
                * \dfn{モニタ} (monitor)
              }%
            }
            +p{
              \dfn{リンク}は2つのプロセス間に双方向に張られる関係で，
              基本的にはリンクしている一方のプロセスが終了すると
              他方のプロセスもそれにつられて（何らかの処理中であろうと）自動で終了させられるというものです．
              リンクが3つ以上のプロセスで連鎖的に張られてていると全部のプロセスが連鎖的に終了するので，
              基本的には “何らかの経路でリンクにより繋がっている複数のプロセスは全部ひとかたまり”
              と考えてよく，その意味で基本的にリンクは “プロセスの集合を同値類で割る機構” です．
              このリンクという機能は “ひとつでも欠けると機能を果たさなくなるプロセスの集合” の間で張り合い，
              （正常終了か異常終了かにかかわらず）どれかが終了したら自動的に全部終了するようにする仕組みです．
            }
            +p{
              リンクは既に起動したプロセスに対して設定や解除をすることもでき，具体的には
              `link/1` や `unlink/1` といった組み込み函数に相手プロセスのPIDを渡すことによって設定/解除できますが，
              大抵の用例およびライブラリの定式化では
              プロセスの起動時に起動元のプロセスから “自分とリンクして起動するか否か” を指定し，
              以後それらのプロセス間のリンクの有無は不変です．
              低級な機能としては，組み込み函数の `spawn/1` を `spawn_link/1` に置き換えて使うと
              呼び出したプロセスとリンクした状態で新しいプロセスを起動することができます\footnote{
                `spawn_link/1` は一見 `spawn/1` と `link/1` とを組み合わせて実装できると思うかもしれません．
                具体的には以下のような具合です：

                \d-code(```
                  spawn_link(F) ->
                      Pid = spawn(F),
                      _ = link(Pid),
                      Pid.
                ```);%

                または以下でも良さそうに思えるかもしれません：

                \d-code(```
                  spawn_link(F) ->
                      ParentPid = self(),
                      spawn(fun() -> _ = link(ParentPid), F() end).
                ```);%

                しかし，実はいずれもデータ競合の可能性を孕んでいます．
                前者は起動元のプロセスで `link(Pid)` が評価されていないうちに新しいプロセスが
                起動直後に終了してしまうと起動元のプロセスが一緒に死にませんし，
                後者は新しいプロセスが `link(ParentPid)` を呼び出す前に
                起動元のプロセスが死んでしまうと新しいプロセスが一緒に死にません．
                このデータ競合を是正するために `spawn_link/1` は別個に組み込み函数として用意されているようです．
                既に述べたようにErlangはわずかな可能性のデータ競合に関しては
                不整合が起きた時に再処理すればいいという方針ですが，
                いくらなんでもそのための監視に関わる機能自体がデータ競合を孕んでいては制御しきれないからか，
                `spawn_link/1` が用意されたのではないかと思われます．
              }．
              より高級なAPI，例えば `gen_server` に準拠したプロセスなら，起動処理として
              \no-break-latin{`gen_server:start/3`} ではなく
              \no-break-latin{`gen_server:start_link/3`} を使うことで
              リンクして起動することができます．
              2つ前の節の `gen_server` の紹介では説明を簡単にする都合で避けましたが，
              \no-break-latin{`gen_server:start/3`} よりもむしろ
              \no-break-latin{`gen_server:start_link/3`} を使うことの方が典型的です．
            }
            +p{
              一方，\dfn{モニタ}は単方向的な関係で，或るプロセスが或る別のプロセスの終了を一方的に検知するのに使います．
              あるプロセス A とプロセス B があるとして，
              B のPIDを表す式を ${e_{\mathrm{pidB}}} と表すことにすると，
              \no-break-latin{`monitor(process,` ${e_{\mathrm{pidB}}}`)`}
              と組み込み函数 `monitor/2` を呼び出すことで A から B にモニタを張ることができます．
              この呼び出しの戻り値はモニタを張ることに伴って生成された
              \dfn{モニタ参照} (monitor reference) と呼ばれる或る種のトークンで，
              少し後で用途を説明します．
            }
            +p{
              プロセス A からプロセス B にモニタが張られていると，
              B が（正常終了・異常終了にかかわらず）終了したときに A に
              \no-break-latin{
                `{'DOWN',` ${v_{\mathrm{monitor}}}`, process,`
                ${v_{\mathrm{pid}}}`,` ${v_{\mathrm{reason}}}`}`}
              という形式の特殊なメッセージが送られてきます．
              ${v_{\mathrm{monitor}}} がモニタ参照で，これによりどのモニタ関係に起因するメッセージなのか判別できます．
              ${v_{\mathrm{pid}}} は終了した B のPID，${v_{\mathrm{reason}}} は終了時の理由です
              （正常終了なら `normal` などになっています）．
              A はこのメッセージの受信を以て B が終了したことを知れるわけです．
            }
            +p{
              モニタ関係は破棄することもできます．その関係に対応するモニタ参照を ${v_{\mathrm{monitor}}} として，
              \no-break-latin{`demonitor(`${v_{\mathrm{monitor}}}`)`}
              を呼び出すとそのモニタ関係が解除されます．
              なお，プロセス2つの同一の組の間の同一方向のモニタを複数個張ることもでき，
              複数のモニタ関係がある状況でモニタ先のプロセスが終了した場合は全てのモニタ関係に対応する
              \no-break-latin{`{'DOWN', `${\ldots}`}`}
              のメッセージが送られてきます．
            }
            +p{
              実際には一定の割合で後述する\dfn{監視ツリー}および `supervisor` という機構にラップされた形で使いますが，
              基本的にはここで紹介したリンクとモニタという機構がプロセス間の監視の根本を担っています．
            }
          >
          +subsubsection{`trap_exit`： リンク機能の例外}<
            +p{
              ややこしいことに，「リンクは双方向関係」という点には例外があり\footnote{
                例外と言いつつ結構使われます．後述の `supervisor` の実装にも使われています．
                単方向の関係はリンクから取り除いてモニタに集約する意味論に改めた方が自然ではないかという
                提案の論文もあります \cite[`SvenssonFredlundEarle2010`]; が，
                今のところそのような破壊的変更には至っていないようです．
              }，
              実際には単方向関係のように使うことができます．
              各プロセスは「リンクしているプロセスが終了してもそれに伴って自動で終了せずメッセージとして捕捉するモード」
              を設定することができるのです．
              このモードはデフォルトでは無効ですが，
              `process_flag(trap_exit, true)` という組み込み函数の呼び出しによって有効にできます．
              大抵はこのモードの有効/無効を切り替えたりはせず，起動直後に設定してそのままということが多いです．
            }
            +p{
              このモードを有効にしていると，リンクしているプロセスが終了したときに自身は死なず，
              \no-break-latin{`{'EXIT',` ${v_{\mathrm{pid}}}`,` ${v_{\mathrm{reason}}}`}`}
              というメッセージが届きます．${v_{\mathrm{pid}}} はリンク関係にあった死んだプロセスのPID，
              ${v_{\mathrm{reason}}} は終了理由の値です．
              このメッセージをモニタの場合の
              \no-break-latin{`{'DOWN',` ${\ldots}`}`}
              と同様に受け取って処理するわけです\footnote{
                ちなみに，以降では触れませんがさらにややこしいことに例外の例外があります：\quad;
                終了理由を `kill` というアトムにして異常終了したプロセスは，
                `trap_exit` のモードが有効か否かにかかわらず問答無用で直接リンクしているプロセスを全て終了させます．
                これによって終了させられたプロセスの終了理由は `killed` になるので，
                この効果はリンク先のリンク先以降には波及しません．
                もうここまで来ると人間に制御するのは困難だろうという気がしてきますが，
                一応機能としてはこういうものがあります．
              }．
            }
          >
          +subsubsection{監視ツリー，`supervisor` モジュール}<
            +p{\REMAINS{監視ツリーとsupervisorについて}}
          >
        >
      >
      +section{Sesterlの開発動機}<
        +subsection{型システムの必要性}<
          +p{
            ここまで前提知識としてErlangの解説をしてきましたが，ここからようやくSesterlの話です．
            Sesterlの開発の動機となったErlangでの不満な点を挙げるなら，
            まずなんといってもErlangプログラムには事実上静的に型がつかないことです．
            Erlangには（既に脚註で触れたように）\dfn{Dialyzer}という型検査器がありますが，
            この型検査器の元になっている\dfn{success typing} \cite[`LindahlSagonas2006`];という体系は
            謂わば後づけ的にErlangに型システムを導入する都合で
            健全性を志向していない型システムのため，
            型検査に通っても実行時にはごく普通に（健全な型システムがあれば弾けそうな，形式のミスマッチによる）エラーが出ます．
          }
          +p{
            実行時に形式の不整合でエラーが出る可能性が機械的に排除できないことそれ自体も一応厄介な点ではありますが，
            それはまあテストの水準で比較的潰せるのでよいとして，
            型がつかないことで真に厄介なのは，それが修正やリファクタリングを極めて困難にする点にあります．
            健全性を満たす型システムの備わった言語なら，例えば或る函数定義の引数や戻り値の形式を変えたら
            それに伴ってその函数を使っている箇所全てで型検査時にエラーが出るようになり，
            そのエラーに従えば網羅的に修正できるのですが，健全性を満たす型システムのない状況だとそのような修正が機械的には補助されず，
            基本的には人力で修正すべき箇所を探し当てる（か或いは旧来の形式も後方互換性のためにサポートし続ける）羽目になってしまいがちです．
            一応その函数に対応するテストをしっかり用意できていればテストが落ちることによって確認できますが，
            テストも人間が用意するものなので網羅されている保証はありませんし，
            型のつかない言語で走らせたテストの失敗は型検査のエラーに比べると何が原因で失敗しているのかが
            些細な形式のミス（例えばどこかで1要素のリスト `[expr]` にすべきところにその要素 `expr` だけを書いてしまっているとか，
            或いは `{{x, y}, z}` とすべきところを `{x, {y, z}}` と書いてしまっているなど）に対して
            あまり解りやすい結果になるとは言えない傾向が顕著で，
            原因を特定して修正するのにかなりの労力を要してしまう状況によく見舞われます．
          }
          +p{
            こうした不満をバッサリ解決しつつ，並行処理が得意というErlangの利点を活かしてプログラムを書きたいというのが
            Erlangに（健全性を満たす）型システムを用意する最大の動機です．
          }
        >
        +subsection{Sesterlの目的と要件}<
          +p{
            さて，前節では単に型をつけたい旨を説明しましたが，
            自分が何を欲しがっているのかという目的の詳細を詰めると以下のようになりました\footnote{
              実際には開発当初から明瞭な言語化をしていたわけではなく，
              おおよそこうしたいと思って設計・実装しているうちに少しずつ煮詰まってきた目的と要件ではあります．
              今後の進展によってさらに変わることも勿論あるだろうと思います．
            }：

            \listing?:(true){
              * 既にErlangで書かれているプログラムをSesterlから利用しやすくするために，
                かつ既にErlangで書かれているプログラムを段階的にSesterlに移植していけるように，わかりやすいFFIを実現したい．

              * Erlangらしいソフトウェアアーキテクチャをそのまま書けるようにしたい．
                特にOTPライブラリはそれ自体には手を加えずにSesterl側から実装をできるだけ自然な形で利用できるようにしたい．

              * 函数の引数がやたらと多かったり或いは引数の一部がオプショナルなものになっていたりしても，
                どの引数がどうやって与えられるのかをなるべく捉えやすいようにしたい．

              * `spawn`，`!`，`receive` などの低級な通信もできるだけErlangの意味論に近い形で実現したい．

              * 例外はひとまずキャッチしないことを前提にしたい．

              * ビヘイビアなどによって依存関係が逆転することもあるので，
                Erlang側からもSesterlで実装された函数を簡単に呼べるようにしたい．

              * むやみに通信を起こすプログラムができあがってしまうスパゲティ化を防ぐために，
                純粋な計算と並行処理が発生する計算とを型の水準で区別できるようにしたい．
                また，可能なら “送受信の振舞い” も型の水準で表現できるようにしたい．
            }%
          }
          +p{
            こうした目的設定をうけて，要件を以下のようにすることとしました：

            \listing?:(true){
              * 基本的にはML風またはErlang風の言語設計とする．

              * FFIの簡便さのため，コンパイルのターゲットとしては
                直接\dfn{BEAM}（＝Erlang VMのバイトコード）を出力するのではなくErlangソースコードを出力するものとする．

              * やはりFFIでの函数定義や使用のわかりやすさのため，ML系言語やHaskellのような部分適用は導入せず，
                函数はアリティをもつことにする．

              * 函数の引数の形式としては通常の引数のほかにラベルつき必須引数とラベルつきオプション引数を用意する．

              * OTPライブラリを型の水準で自然に定式化するために，ファンクタをもつモジュールシステムを導入する．

              * 通信が発生する計算はモナドでくるむようにし，
                各並行処理ないしプロセスは “自分がどんな型のメッセージを受け取れるか” の情報をトラックする．
                これを用いて `spawn`，`!`，`receive` 相当の言語機能に型をつける．
                可能なら\dfn{session type} \cite[`Honda1993`];や
                \dfn{multiparty session type} \cite[`HondaYoshidaCarbone2008`];を備えつける．
            }%
          }
        >
        +subsection{他のAltErlang言語}<
          +p{
            やはり人間皆似たことを考えるのか，
            同様の動機でErlangに型をつけようとして創られた言語はSesterl以外にもいくつかあります：

            \listing?:(true){
            * \dfn{Alpaca} \cite[`Alpaca`];
              ** OCamlやElmに近い構文と意味論をもち，
                 各プロセスがどんな型のメッセージを受け取れるかの情報を静的に検査することができます．
            * \dfn{Gleam} \cite[`Gleam`];
              ** Rust風の構文と意味論をもつAltErlangです．函数はアリティをもち，ラベルつき引数などの機能ももっています．
                 メッセージにはコア言語では型をつけない方針で，ライブラリの水準で型つけを実現する方針のようです．
                 2021年11月現在非常に精力的に開発されており，つい最近JavaScriptバックエンドも実装されたようです．
            * \dfn{Caramel} \cite[`Caramel`];
              ** OCaml互換の構文で開発されているものです．
                 PIDはメッセージの型をパラメータにとりますが，モナドによる純粋・並行の区別はないようです．
            * \dfn{Hamler} \cite[`Hamler`];
              ** Haskell風の構文と意味論をもつAltErlangです．型クラスを備えていたりします．
                 並行処理に関するモナドがありますが，メッセージの型をパラメータにとるわけではないようです．
                 また，OTPライブラリのビヘイビアは型クラスで定式化されているようです．
            }%
          }
          +p{
            Sesterlの開発を構想した当時，Alpacaと（当時の）Gleamがどんな言語であるか試したのですが，
            当時の自分は特にコア言語の水準でメッセージに型をつけて将来的にsession typeを入れることを重視していたので，
            これらとは別に新たに開発を開始することとしました．
          }
          +p{
            1年半ほど開発して，メッセージに対する型つけも簡潔かつ或る程度便利なものになりましたが，
            session typeは結局それほど強い必要性を感じることがなかったため今に至るまで入っておらず\footnote{
              もともと “Sesterl” という名前は “a session-typed Erlang” に由来してつけたものだったので
              現状としてはちょっと歪な命名になってしまった感があります．
            }，
            結果的には（後で触れますが）OTPライブラリを型つけするためのF-ing Modulesに基づくモジュールシステムが
            とりわけ顕著な独自性となりました．
          }
        >
      >
      +section{Sesterlの言語設計}<
        +subsection{基礎的な言語機能}<
          +subsubsection{基本的な構文}<
            +p{
              まず基本的な構文は以下のような例でわかると思います：

              \d-code(```
                module Calc :> sig
                  val fact : fun(int) -> int
                  val sum : fun(list<int>) -> int
                  val swap<$a, $b> : fun({$a, $b}) -> {$b, $a}
                  val have_same_length<$a, $b> : fun(list<$a>, list<$b>) -> bool
                end = struct
                  open Stdlib

                  val fact(n) =
                    let rec aux(acc, n) =
                      if n <= 0 then acc else aux(n * acc, n - 1)
                    in
                    aux(1, n)

                  val sum(ns) = List.foldl(fun(acc, n) -> acc + n end, 0, ns)

                  val swap({x, y}) = {y, x}

                  val rec have_same_length<$a, $b>(xs : list<$a>, ys : list<$b>) : bool =
                    case {xs, ys} of
                    | {[], []}                 -> true
                    | {_ :: xtail, _ :: ytail} -> have_same_length(xtail, ytail)
                    | _                        -> false
                    end
                end
              ```);%
              \d-code(```
                require Calc

                module SomeModule = struct
                  val main() = Calc.sum([3, 1, 4, 1, 5, 9, 2])
                end
              ```);

              構文はおおよそML系のものを蹈襲していますが，以下のような特徴があります：

              \listing?:(true){
                * ソースコードのファイルは1つのモジュールの束縛
                  `module` ${X} `= struct` ${\ldots} `end`
                  であり，シグネチャが必要ならモジュール名の直後に
                  `:> sig` ${\ldots} `end`
                  と追記することができる．

                * ファイルの先頭に
                  \no-break-latin{`require` ${X}}
                  と書くことで同一パッケージ中の別ファイルであるモジュール ${X} を読み込める．
                  依存する別パッケージが提供するモジュールは，設定ファイルに記載しておくと
                  どこでも使えるようになる．
                  例えば上記の例では `Stdlib` が別のパッケージに由来するモジュールで，
                  `open Stdlib` で中身が取り出されているので少しわかりにくいが，
                  `Stdlib.List.foldl` が使われている．

                * ストラクチャのメンバとなる（つまり `struct` ${\ldots} `end` 直下の）大域的な束縛は
                  `val` で始め，函数内の局所的な束縛は `let` で行なう．
                  後者は函数のほかに
                  \no-break-latin{`let n = 42 in` ${\ldots}}
                  のように函数でない値も当然束縛できるし，またパターンも
                  \no-break-latin{`let {x, _} = pair in` ${\ldots}}
                  のように使えるが，前者は函数しか束縛できない\footnote{
                    これは後述しますがErlangのモジュール中では函数しか定義できないことに由来します．
                  }．（相互）再帰函数を定義したい場合は
                  `val rec` \no-break-latin{${f_1}`(`${\ldots}`) =` ${e_1}}
                  `and` ${\ldots}
                  `and` \no-break-latin{${f_n}`(`${\ldots}`) =` ${e_n}}
                  のように記述する．`let` の場合も同様．

                * 前述の通り函数はCurry化されないため，函数の型は
                  （一般的な \no-break-latin{${\tau'} `->` ${\tau}} などではなく）
                  \no-break-latin{`fun(`${\tau_1}`,` ${\ldots}`,` ${\tau_n}`) ->` ${\tau}}
                  の形式であり，例えば
                  \no-break-latin{`fun(`${\tau_1}`,` ${\tau_2}`) ->` ${\tau}}
                  は
                  \no-break-latin{`fun(`${\tau_1}`) -> fun(`${\tau_2}`) ->` ${\tau}}
                  とは異なる型である．適用も例えば
                  `List.foldl f i xs`
                  ではなく
                  `List.foldl(f, i, xs)`
                  などと書く．やはり
                  ${e}`(`${e_1}`,` ${e_2}`)`
                  と
                  ${e}`(`${e_1}`)(` ${e_2}`)`
                  とは（具象構文としてだけでなく）抽象構文として異なる．

                * 具象構文上型コンストラクタは前置で，例えば（`int list` ではなく）`list<int>` と記述する．
                  複数の型引数がある場合は `result<int, error>` のようにコンマ区切り．
                  高階の型コンストラクタはサポートしていない．

                * 型註釈を書かずともlet多相での主要型を推論してくれる．
                  再帰函数については，型註釈を全ての引数と戻り値について書いていれば多相再帰も受理する．

                * 直積型は
                  \no-break-latin{`{`${\tau_1}`,` ${\ldots}`,` ${\tau_n}`}`}
                  の形で書き，組（タプル）はErlangと同様に
                  \no-break-latin{`{`${e_1}`,` ${\ldots}`,` ${e_n}`}`}
                  の形で書く．
                  1要素だけの直積型 `{`${\tau}`}` と組 `{`${e}`}` もいくつかの用途のために用意されている．

                * リストの式は
                  \no-break-latin{`[`${e_1}`,` ${\ldots}`,` ${e_n}`]`}
                  とコンマ区切りで書くほか，通常のいわゆるコンスセルの書き方
                  \no-break-latin{${e_1} `::` ${e_2} `::` ${\ldots} `::` ${e_n} `:: []`}
                  も可能．パターンでも同様．

                * 函数定義や函数抽象の引数で（単一の変数に限らず）パターンを使うことができる．

                * 型変数は `$a` のようにドル記号が接頭辞としてつく．
                  全称量化は `<$a, $b>` のようにコンマ区切りで型変数を並べて `<` と `>` で括り，
                  束縛される函数名の直後に書く．シグネチャ中の宣言だけでなく，
                  \no-break-latin{`val have_same_length<$a, $b>(`${\ldots}`) =` ${\ldots}}
                  のように実装中の型註釈でもそのように書くことができる．
              }%
            }
          >
          +subsubsection{代数的データ型とモジュールによる抽象化}<
            +p{
              これも以下の例でほぼ伝わるかと思います：

              \d-code(```
                module BinTree :> sig
                  type t :: (o) -> o
                  val leaf<$a> : fun($a) -> t<$a>
                  val node<$a> : fun($a, t<$a>, t<$a>) -> t<$a>
                  val size<$a> : fun(t<$a>) -> int
                end = struct
                  type t<$a> =
                    | Empty
                    | Node($a, t<$a>, t<$a>)

                  val leaf(x) =
                    Node(x, Empty, Empty)

                  val node(x, tree1, tree2) =
                    Node(x, tree1, tree2)

                  val rec size(tree) =
                    case tree of
                    | Empty                 -> 0
                    | Node(_, tree1, tree2) -> 1 + size(tree1) + size(tree2)
                    end
                end
              ```);%

              `type t :: (o) -> o` が抽象化された型コンストラクタの宣言で，`(o) -> o` は
              1個の型引数をとることを表す種（カインド）です．2個の場合は `(o, o) -> o` という具合にコンマ区切りで増えます．
              高階の種はサポートしていません．
            }
          >
          +subsubsection{列多相によるレコード}<
            +p{
              レコードとは “ラベルつきの組” であり，Sesterlでは
              \no-break-latin{`{`${l_1} `=` ${e_1}`,` ${\ldots}`,` ${l_n} `=` ${e_n}`}`}
              の形で構築でき，
              \no-break-latin{${e}`.`${l}}
              で射影して成分を取り出せます．また，レコード ${e} に対して一部のラベルの値だけを上書きしたレコードも
              \no-break-latin{`{`${e} `with` ${l_1} `=` ${e_1}`,` ${\ldots}`,` ${l_n} `=` ${e_n}`}`}
              で構築できます．
            }
            +p{
              レコードで非自明なのは，射影や更新にどんな型をつけるかです．
              例えば以下の `get_foo` にはどんな型がつくべきでしょうか？

              \d-code(```
                val get_foo(r) = r.foo
              ```);%

              例えばOCamlの場合だと，ラベルは各々1つのレコード型に属するものとして扱われるため，
              `get_foo` に相当する函数は `foo` というラベルをもつと定義された
              唯ひとつのレコード型のみに対して定義された函数として単相になります．
              一方，ラベルが特定の型に紐づくものとは扱われない言語設計も当然ありえて，
              上記のような函数に “`foo` というラベルをもつレコードはなんでも受け取れて，その `foo` の型を戻り値の型とする”
              ということを表す多相な型をつけたりすることも十分考えられます．
              問題はその多相性をどう定式化するかで，既存の体系だと特に2つの方法がよく知られています：

              \listing?:(true){
                * \dfn{SML\#}方式のレコード多相 \cite[`Ohori1995`];：
                  \ 式・型・種の3段階からなる2階の型システムで，
                  例えば `get_foo` 相当の函数には
                  ${
                    \forall \alpha \mathrel{::} \mathrm{U}.
                    \ \forall \beta \mathrel{::} \{\{\text!{`foo`} : \alpha\}\}.
                    \ \beta \to \alpha
                  }
                  という具合の型がつきます．ここで ${\mathrm{U}} は任意の型につく種，
                  ${\{\{\text!{`foo`} : \alpha\}\}} は
                  “`foo` というラベルをもち，それに対応する型が ${\alpha} であるようなレコード型” 全体につく種です．
                  この型システムの特徴は，レコードに対して多相に型つけできるだけでなく，
                  拡張や結合など一部のレコードに対する操作ができないという制約を設けつつも
                  実行時のオーバーヘッドを減らせるような定式化になっていることです．

                * \dfn{列多相} \cite[`GasterJones1996`];：
                  \ いろいろな変種がありますが，概して\dfn{列} (row) という構文的対象が型とは別にあるのが特徴です．
                  列とは大雑把に言えば “レコードのラベルと型の組み合わせの一部だけ切り出したもの” で，
                  例えば `{foo : int, bar : bool, baz : string}` の “`bar : bool, baz : string` の部分”
                  といったものが列に該当します．
                  2階の型システムとして列多相を定式化すると，
                  `get_foo` 相当の函数には
                  ${
                    \forall \alpha \mathrel{::} \mathrm{Type}.
                    \ \forall \rho \mathrel{::} \mathop{\mathrm{Row}}\{\text!{`foo`}\}.
                    \ \mathop{\mathrm{record}}\{\text!{`foo`} : \alpha \| \rho\} \to \alpha
                  }
                  などという型がつく具合になります．
                  ここで ${\alpha} は通常の型変数で，${\mathrm{Type}} という種がつきますが，
                  ${\rho} は\dfn{列変数}と呼ばれ，列が全称量化されたものです．
                  列 ${r} に対して ${\mathop{\mathrm{record}}r} が “${r} を内容としてもつレコード型” であり，
                  ${\{l : \tau \| r\}} とは “${l : \tau} を列 ${r} の先頭につけ足してできる列” です．
                  レコードに含まれるものとして意味を為すために1つの列に於いては各ラベルは高々1回までしか出現してはいけないため，
                  ${\{l : \tau \| r\}} に於いて ${r} はラベル ${l} を含んでいてはならず，したがってここでの
                  ${\{\text!{foo} : \alpha \| \rho\}} が意味を為すためには
                  列変数 ${\rho} は ${\text!{foo}} を含む列にinstantiateされてはいけないことになります．
                  こうした制約を表現するために列の種は ${\mathop{\mathrm{Row}}L} とラベルの集合 ${L} を伴っており，
                  ここでは ${L} に相当するのが ${\{\text!{foo}\}} という1元集合というわけです．
              }%
            }
            +p{
              Sesterlではv0.1.xの頃にはSML\#のレコード多相を導入していました\footnote{
                これは何か列多相と比較の上決めたわけではなく，
                単に開発開始当時に筆者がSML\#のレコード多相くらいしかレコードを多相的に扱う手法の直観を
                獲得していなかったことに起因します．
              }が，次第に以下のような点が気になってきました：

              \listing?:(true){
                * レコードに関してパフォーマンスがクリティカルに必要なわけではないので，
                  実行時のオーバーヘッドを減らすようなコンパイル処理を実装するためにこの型システムを活かしたりはしていないし，
                  それならばレコードに対する操作を制約している意味があまりない．

                * 種が型に構文的に依存するため，以下のようなことが問題になる：

                  ** 通常のlet多相と違い型変数の全称量化の順序に意味があるなど
                     そもそも型システムとして幾分か複雑なため，型推論上の型と種の扱い方も複雑になりやすい．
                     量化の順番に意味があるというのは，例えば上記の `get_foo` の型つけの場合に量化の順序を入れ替えて
                     ${
                       \forall \beta \mathrel{::} \{\{\text!{`foo`} : \alpha\}\}.
                       \forall \alpha \mathrel{::} \mathrm{U}.
                       \ \beta \to \alpha
                     }
                     とすると意味を為さない別の型になってしまうことなど．

                  ** 他の型システムの拡張や型推論処理を内部的に効率化したアルゴリズムなどと
                     このレコードに関する推論が適切に両立できるかが非自明．
              }%
            }
            +p{
              そこでこれを緩和する方法としてSesterl v0.2.0からはレコード型の定式化を列多相に切り替えることにしました．
              上記の `get_foo` に対しては以下のように型がつきます：

              \d-code(```
                val get_foo<$a, ?$r :: (foo)> : fun({foo : $a | ?$r}) -> $a
              ```);%

              列変数は `?$` という接頭辞をもつことにし，列変数に対する種は `(`${L}`)` の形で
              記述することにしました（複数のラベルからなる集合の場合はコンマ区切りで書きます）．
              また，単に `{foo : $a | ?$r}` と書いただけでレコード型として扱い，
              列自体を書く方法は（今のところ必要に感じていないため）ひとまず提供しないことにしました．
            }
            +p{
              列多相に切り替えた際，型推論アルゴリズムの実装をかなり簡略化できたほか，
              既存のレコード多相に準拠して既に書いていたプログラムは型註釈を除いて書き換える必要なく移行でき，
              使い勝手が良くなりました．
              というわけで現在のSesterlでは列多相に基づいたレコードの型つけが採用されています．
            }
          >
          +subsubsection{ラベルつき引数}<
            +p{
              さて，引数が多くなっても何の引数なのかわかりやすくするために，かつ典型的な値が決まっている引数は適宜省略できるように，
              ラベルつき引数を導入したいのでした．
              まず，ラベルつき必須引数は “単にラベルを辞書順で並べて通常の引数に帰着する” という具合の方法で比較的簡単に実現できます．
              というわけで以下のように `-foo` というラベルによって必須引数を書けるようにしました：

              \d-code(```
                val rec foldl(-f f, -init init, -list xs) =
                  case xs of
                  | []      -> init
                  | y :: ys -> foldl(-init f(init, y), -list ys, -f f)
                  end
              ```);%

              再帰の適用で引数の順序が定義の際の引数の順序と違っていますがこれでも問題なく通るという算段です．
              この `foldl` には以下のように型がつきます：

              \d-code(```
                val foldl<$a, $b> : fun(-f fun($a, $b) -> $a, -init $a, -list list<$b>) -> $a
              ```);%

              というわけでラベルつき必須引数のサポートは簡単です．
            }
            +p{
              一方でラベルつきオプション引数は結構非自明な点があります．
              とりあえず，必須引数では `-foo` だったラベルの形式をオプション引数では `?foo` にして，
              適用時に省略されたら `None` が渡されたことに，
              `?foo` ${v} のように値が与えられていたら `Some(`${v}`)` が渡されたことにすることを考えましょう．
              ラベルつきオプション引数をもつ函数を定義する側はこれだけでOKです．例えば以下のように使えます：

              \d-code(```
                val succ(n : int, ?diff diff_opt : option<int>) : int =
                  case diff_opt of
                  | None       -> n + 1
                  | Some(diff) -> n + diff
                  end
              ```);%

              しかし，次のような高階函数にはどんな型をつけるべきでしょうか？

              \d-code(```
                val use_optional(f) = f(42, ?foo 57) + 1
              ```);%

              特にこの函数の引数 `f` にはどんな型がつくべきでしょうか？\quad;
              `fun(int, ?foo int) -> int` のような型を想定するかもしれませんが，
              “`?foo` のほかに `?bar` のようなオプション引数も受け取れて，ここでは単に `?foo` しか与えられないだけ”
              という函数も `f` として適格なため，このことを表現する多相な型をつけたくなります．
            }
            +p{
              実は，前節で触れた列多相をこのようなオプション引数の型つけに転用することができます．
              これは同様の仕組みを取っている論文や実装を見たことはなく，筆者が考案したつもりのものですが，
              仕組みとしてはシンプルであって比較的すぐ思いつくようなものです\footnote{
                多分大丈夫だろうとは信じているものの，
                この手法の正当性（保存や進行といった型安全性）を証明したというわけではないです．
                論文にしたためるほどの内容とは思いませんが，餘裕があるときに証明してみたいことではあります．
              }．
            }
            +p{
              直観としては1つの函数のとるオプション引数全体を列だとみなすという方法です．
              すなわち，（簡単のためラベルつき必須引数は通常の引数と同一視して扱うこととして）函数の型は
              \no-break-latin{`fun(`${\tau_1}`,` ${\ldots}`,` ${\tau_n}`,` ${r}`) ->` ${\tau}}
              という具合に列 ${r} を1つオプション引数用にもっていると考えます．
              すると，上記の `use_optional` は
              \no-break-latin{%
                ${\forall\rho \mathrel{::} \mathop{\mathrm{Row}}\{\text!{`foo`}\}.}
                `fun(fun(int,` ${\{\text!{`foo`} : \text!{`int`} \| \rho\}}`) -> int) -> int`}
              という型をつければよさそうだ，という気がしてきます．
              こうして餘分なオプション引数をもつ函数でも列変数で吸収して扱えるようになります．
              Sesterlの具象構文としては以下のように記述することにしました：

              \d-code(```
                val use_optional<?$r :: (foo)> : fun(fun(int, ?foo int, ?$r) -> int) -> int
              ```);%
            }
          >
          +subsubsection{FFI}<
            +p{
              FFIは特にErlang製の既存実装を再利用しやすくしたり
              Erlang製の実装からSesterl製の実装への段階的な移行を容易にしたりするために
              是非とも簡潔なものにしたい機能でした．以下のような記述でFFIが実現できます：

              \d-code(````
                val binary_to_chars : fun(binary) -> list<char> = external 1 ```
                  binary_to_chars(Bin) ->
                      erlang:binary_to_list(Bin).
                ```
              ````);%

              すなわち，文字列リテラルでErlangの函数定義が直接書け，それに型をつけてSesterl側から使うことができます．
              `external` の直後にはアリティを指定します\footnote{
                このアリティはSesterlコンパイラが `-export` の内容を出力するのに必要です．
                文字列リテラル内のErlangのコードを構文解析するようにすればアリティを書く必要はないのですが，
                現状ではErlangコードは構文解析せず出力するErlangソースコードにそのまま貼りつける仕組みになっています．
              }．Sesterlの値とErlangの値との紐づけは以下のようになっています：

              \listing?:(true){
                * 整数，浮動小数点数，バイナリ，PID，リスト，タプルなどの値はそのまま自然な形でErlangの値になっている．

                * レコードは，ラベルをアトムのキーとするマップで表現される．

                * 代数的データ型の値は，引数を取らないコンストラクタ ${C} は小文字始まりのアトム ${c} で，
                  引数を取るコンストラクタ
                  \no-break-latin{${C}`(`${v_1}`,` ${\ldots}`,` ${v_n}`)`}
                  はアトムを先頭とするタプル
                  \no-break-latin{`{`${c}`,` ${v_1}`,` ${\ldots}`,` ${v_n}`}`}
                  で表現される．
                  ${C} と ${c} の対応は例えばアッパーキャメルケースの `SomeConstructor` が
                  スネークケースの `some_constructor` に変換される要領．
                  ただし，`option` 型の `Some` と `None` は利便性のため例外的に
                  それぞれ `ok` と `error` で表現される\footnote{
                    ユーザ定義の代数的データ型でも，本来の規則とは違うアトムにコンパイルしたい場合は
                    そのように指定する註釈がつけられるようにしています．
                  }．

                * 函数定義および函数抽象では，通常の引数とラベルつき必須引数は
                  Erlangの普通の引数として扱われ，ラベルつき必須引数はラベルの辞書順で並ぶ．
                  オプション引数は最後の1引数として単一のマップになっており，
                  オプション引数をひとつも与えない場合はその最後の1引数が缺ける．
                  そのため，FFIの函数でオプション引数を受け取るものにしたい場合は
                  Sesterl側では1つの函数であっても
                  Erlang側ではオプション引数のマップを受け取るものと受け取らないものの2種を与える必要がある．
              }%
            }
          >
          +subsubsection{並行処理}<
            +p{\REMAINS{並行処理}}
          >
        >
        +subsection{SesterlをOTP Design Principlesに適合させるために必要だった言語機能たち}<
          +p{\REMAINS{ファンクタ，static interpretation，future workとして再帰モジュール}}
        >
      >
      +section{天九のルール}<
        +p{
          次章で実際にSesterl（とElm）を用いてオンラインゲームを設計・実装した話をする前に，
          ここではちょっと休憩して天九のルールを簡単に紹介します．
          正直なところ話の流れとしてはそんなに必須の内容ではなく，
          大体麻雀のように配牌が配られて4人が逐一出していくという手順を経る一般的な卓上ゲームであることさえ
          把握していれば次章が読めるのですが，
          そもそも天九のルールを記載した和文の文献が少ないので布教用として書いておきます．
          なかなか良いゲームで，比喩でなく1日中やっていても飽きないくらいのめり込めます．
          もし良ければここでルールを覚えて天九Onlineで遊んでみてください．
          気に入ったら実際に天九牌を入手して物理的に遊んでみることもおすすめします\footnote{
            日本ではなかなか出回っていませんが，
            ゲームマーケットなどの即売会で販売している方がいたりするほか，
            オンラインで中華圏から個人輸入する手段もあります．
            筆者は主に輸入代行業者に依頼して入手し5セットくらい所有しています．
            いろんなメーカーのものがあるようですが，なるべく分厚い牌のものを選ぶとよいです．
            本体価格は結構手頃で1000円〜2000円程度だったりしますが，
            重量があるので運搬費がかさみ，1セットで4000〜5000円程度にはなります．
            また，重量に対する運搬費は概して ${y} 切片が大きいので，
            同時にいくつも購入すると1セットあたりの出費は割安になったりします．
          }．
        }
        +subsection{使用するコンポーネント}<
          +p{\REMAINS{牌の画像など}}
        >
        +subsection{ゲームの手順や牌の出し方}<
          +p{\REMAINS{天九のルールを簡単に紹介}}
        >
        +subsection{勝敗の決定と得点の移動}<
          +p{\REMAINS{天九のルールを簡単に紹介}}
        >
      >
      +section{ゲームサーバとクライアントの設計}<
        +p{\REMAINS{設計の話．これは直接Erlang/OTPで実装する場合でも全く同じ}}
      >
      +section{まだ納得していないところ}<
        +p{\REMAINS{再帰モジュールなど}}
      >
      +section{まとめ}<
        +p{\REMAINS{まとめ}}
      >
    >
  >

end
