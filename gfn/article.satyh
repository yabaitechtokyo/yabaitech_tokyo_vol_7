@require: itemize
@require: code
@require: base/image

@require: class-yabaitech/yabaitech

module Gfn : sig

  val article : block-text

end = struct

  let-inline ctx \no-break-latin it =
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let deco _ _ _ _ = [] in
    script-guard Latin (inline-frame-outer pads deco (read-inline ctx it))

  let bibliography = [
    (`GasterJones1996`, Article(|
      author = {| Benedict R. Gaster | Mark P. Jones |};
      title = {A polymorphic type system for extensible records and variants};
      journal = {Technical Report NOTTCS-TR-96-3};
      volume = None;
      number = None;
      pages = (1, 12);
      year = 1996;
    |));
    (`Honda1993`, Article(|
      % https://doi.org/10.1007/3-540-57208-2_35
      author = {| Kohei Honda |};
      title = {Types for dyadic interaction};
      journal = {Lecture Notes in Computer Science (CONCUR’93)};
      volume = Some(715);
      number = None;
      pages = (509, 523);
      year = 1993;
    |));
    (`HondaYoshidaCarbone2008`, InProceedings(|
      % https://doi.org/10.1145/1328438.1328472
      author = {| Kohei Honda | Nobuko Yoshida | Marco Carbone |};
      title = {Multiparty asynchronous session types};
      booktitle = {
        Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on
        Principles of Programming Languages
      };
      series = Some({POPL’08});
      volume = None;
      number = None;
      pages = (273, 284);
      year = 2008;
    |));
    (`LindahlSagonas2006`, InProceedings(|
      % https://it.uu.se/research/group/hipe/papers/succ_types.pdf
      author = {| Tobias Lindahl | Konstantinos Sagonas |};
      title = {Practical type inference based on success typings};
      booktitle = {
        Proceedings of the 8th ACM SIGPLAN International Conference on
        Principles and Practice of Declarative Programming};
      series = Some({PPDP’06});
      volume = None;
      number = None;
      pages = (167, 178);
      year = 2006;
    |));
    (`Caramel`, WebSite(|
      author = {| Leandro Ostera et al. |};
      title = {Caramel};
      url = `https://github.com/AbstractMachinesLab/caramel`;
      year = 2020;
    |));
    (`Hamler`, WebSite(|
      author = {| Feng Lee et al. |};
      title = {Hamler};
      url = `https://github.com/hamler-lang/hamler`;
      year = 2019;
    |));
    (`Alpaca`, WebSite(|
      author = {| Jeremy Pierre et al. |};
      title = {Alpaca};
      url = `https://github.com/alpaca-lang/alpaca`;
      year = 2016;
    |));
    (`Gleam`, WebSite(|
      author = {| Louis Pilfold et al. |};
      title = {Gleam};
      url = `https://github.com/gleam-lang/gleam`;
      year = 2018;
    |));
    (`RossbergRussoDreyer2014`, Article(|
      author = {| Andreas Rossberg | Claudio Russo | Derek Dreyer |};
      title = {F-ing modules};
      journal = {Journal of Functional Programming};
      volume = Some(24);
      number = Some({5});
      pages = (529, 607);
      year = 2014;
    |));
  ]

  let article = '<
    +chapter ?:(`gfn-article`)(|
        bibliography  = bibliography;
        title         = {自作言語でオンラインゲームを実装した話};
        author        = {gfn};
        title-for-toc = None;
        subtitle      = None;
    |)<
      +section{はじめに}<
        +p{
          \dfn{Sesterl}（セスタール）という自作言語で\dfn{天九Online}というオンラインゲームを実装した話を報告したいと思います．
          Sesterlは2020年4月頃から筆者が開発している計算機言語で，
          簡単に言えば\dfn{Erlang}という既存の計算機言語に静的な型システムを搭載することを目的としているものです．
          要するに，JavaScriptに対するTypeScript，PureScript，Elm，ReScriptといった立ち位置の言語を
          Erlangに関して実装しようという試みであり，AltJSになぞらえて言えば
          AltErlangという具合の言語です．
          Erlangはアクターモデルに基づいた意味論をもち，並行処理や分散処理に関する機能がビルトインで提供されているなど
          並行並列に特に強みをもつ言語ですが，静的に型がつかず\footnote{
            一応\dfn{success typing} \cite[`LindahlSagonas2006`];という型システム
            およびその型検査器の実装である\dfn{Dialyzer}がありますが，
            後づけで導入されたものであって健全性 (soundness) を満たすことを志向した型システムではなく，
            型がつくことによって保証できるプログラムの性質はかなり弱い主張に留まっており，
            型検査に通っても実行時に形式の不整合でエラーが起きることはごく普通にあります．
          }，実装の正しさを保証したりリファクタリングを施したりするのにかなり苦労する言語です．
          これを解決することを企図して開発しているのがSesterlというわけです．
        }
        +p{
          後々もう少し詳細に触れますが，Sesterlの型システムの概要を言うと，以下のようなものが備わっています：

          \listing{
            * \dfn{Damas–Milner多相}（いわゆるlet多相）およびその\dfn{Hindley–Milner型推論}
            * 列多相によるレコード型 \cite[`GasterJones1996`];
            * 函数のラベルつき必須引数，および列多相を利用したラベルつきオプション引数
            * \dfn{F-ing Modules} \cite[`RossbergRussoDreyer2014`];に基づく，ファンクタなどを扱えるモジュールシステム
              ** このモジュールシステムは特に `gen_server` や `supervisor` といった\dfn{OTPライブラリ}を型安全に
                 ラップするのに利用しています．
            * 純粋な計算と並行処理とを区別するためのモナド
            * Erlangで実装した函数に型註釈をつけてSesterl側で使えるようにするFFI
          }%
        }
        +p{
          1年ほど開発を続け，Sesterlも或る程度成熟してきたのですが，
          「そうはいっても本当に実用に堪えるものになっているだろうか」という疑問が湧き，
          また丁度数年前からいつか実装したいと思っていたゲームがあったので，
          2021年5月末頃からSesterlを用いて実際に稼働するオンラインゲームのサーバサイドを実装してみることにしました．
          そうして（不足を感じたら適宜Sesterlの方も拡張しつつ）ひとまず動作するようになったのが天九Onlineというゲームです．
          天九Onlineは\dfn{天九}または\dfn{打天九}という中国大陸や台湾などで古くから遊ばれている既存の卓上ゲームを実装したもので，
          これは\dfn{天九牌}という32枚1セットの牌を使ったトリックテイキングゲーム\footnote{
            概して次のような性質を満たすルールのゲームを\dfn{トリックテイキングゲーム}と言います：

            \listing{
              * 1ゲームが複数の\dfn{トリック}という小さい勝負からなる．
              * 最初はプレイヤー全員に同じ枚数の手札が渡されている．
              * 各トリックでは，最初の手番の人から順に各プレイヤーが1回ずつ手札から場に札を出し，
                全員分出揃ったらその出揃ったカードに基づいてそのトリックの勝敗を決める．
                勝った人が次のトリックの最初の手番となる．
              * トリックで場に出たカードのうちどれが勝つかの判定基準は，
                最初の手番のプレイヤーが出した札である\dfn{台札}によって変わる．
              * 最後のトリックが終わったら，
                それまでの各トリックでの勝敗などをもとに何らかの条件でゲーム全体の勝敗や得点の移動を決める．
            }%

            いわゆるトランプを使って遊ぶトリックテイキングゲームの例としては\dfn{ハーツ}や\dfn{ナポレオン}などが有名です．
          }です．
          天九のルールについても簡単に紹介しつつ，実際に卓上ゲームが対戦できる小さいサーバをどのように設計・実装したか紹介します．
        }
        +p{
          趣味で言語処理系を実装する方は世の中に数多くいらっしゃると思いますが，
          大方の自作言語は制作者自身の言語処理系への理解のために創られたものであったりして，
          実用可能な水準まで作り込む経験談はあまり見かけないように思います．
          実用を目的としてドッグフーディングで自作言語を作り込むのはチマチマとした改善を継続する地味ながら執念を要する開発ですが，
          実際に自作言語のおかげで（そうでない場合よりも）高い生産性を発揮できていることが実感できたときの欣快はひとしおです．
          そんなわけで，ちょっと自己満足的な側面も含んでしまいますが，
          自作言語を実用してゲームを実装しつつ言語もドッグフーディングで改善していった過程を簡単に共有できればと思い，記事にしました．
        }
        +subsection{想定する前提知識}<
          +listing{
            * 静的型つきの函数型プログラミングに関する基礎的な理解．
              ** 例えばHaskellやOCamlでプログラムを書いたことがある，単純型の型つけ規則を眺めたことがあるなど．
            * Webアプリケーションの仕組みに対する基礎的な理解．
              ** クライアント-サーバモデルという概念やHTTPの規格の概要を把握しているなど．
          }
        >
      >
      +section{Erlangの簡単な解説}<
        +p{
          SesterlはErlangという既存の言語をラップするために開発されました．
          では元々のErlangとはどんな言語なのでしょうか？
          おそらく「Erlangという名前くらいは聞いたことがあるが使ったことは全くない」という読者も多いかと思うので，
          簡単にErlangの構文や意味論について説明します．
          とはいえErlangに入門するための文書は公式ドキュメントはもとより非公式のものもいくらでもあるはずなので，
          ここで懇切丁寧に解説するつもりはなく，
          全く読み書きしたことのない人に最低限おおよそどんな言語なのかの雰囲気を掴んでもらうために
          ごく簡単にかいつまんで記載します．
        }
        +subsection{基本的な構文と意味論}<
          +p{
            前述の通り，Erlangの意味論はいわゆる函数型言語のそれを基調としており，
            例えば階乗函数 `fact` や整数のリストを受け取りその総和を返す函数 `sum` は以下のように書けます：

            \d-code(```
              -module(calc).
              -export([fact/1, sum/1]).

              fact(N) ->
                  case N =< 1 of
                      true  -> 1;
                      false -> N * fact(N - 1)
                  end.

              sum(Ns) ->
                  lists:foldl(fun(N, Acc) -> N + Acc end, 0, Ns).
            ```);%

            変数の名前は大文字始まり，トップレべルで定義される函数の名前は小文字始まり\footnote{
              トップレベルの函数の名前は正確には後述のアトムの形式と一致し，単引用符で括って一般の文字列が名前として使えます．
            }，函数定義の終わりにはピリオドを打つ，
            `case` 式によるパターンマッチングは枝の区切りにセミコロンを使う，
            他のモジュールの函数を呼び出すには `lists:foldl` などとモジュール名と函数名をコロンで繋いで書くなど
            かなりアクの強いProlog風の具象構文をもっていますが，
            Lisp諸方言，Haskell，OCamlあたりに親しみのある方なら
            函数定義についてはわりと構文から意図するところが推測できるのではないかと思います．
            1行目はこのソースファイルが記述するモジュールの名前を，
            2行目はソースファイル内で定義されている函数のうちどれを公開するか（＝モジュール外から呼び出せるようにするか）を記載しています．
            `fact/1` が階乗函数の名前で，`/1` はアリティ（＝何個の引数をとるか）を表します．
            アリティが名前の一部なのは，函数が（HaskellやOCamlなどと違い）Curry化されておらずアリティをもち，
            かつ同一の名前で異なるアリティの函数は全く別の（たまたま名前が同じ）函数として扱うことを許す言語設計になっているためです．
            特に，アリティの異なる補助函数は同名にする慣習があり，
            上記の `fact/1` を末尾呼び出し再帰になるように書き換えるときには以下のように
            補助函数を `fact/2` としたりします：

            \d-code(```
              fact(N) ->
                  fact(1, N).

              fact(Acc, N) ->
                  case N =< 1 of
                      true  -> Acc;
                      false -> fact(Acc * N, N - 1)
                  end.
            ```);%

            なお，パターンマッチングやそれによる分岐は函数の引数でも行なえて，
            また `when` 節によりマッチする条件を加えることができる\footnote{
              ただし，`when` 節の中では限られた組み込み函数しか使えないように制限されています．
              これは `when` 節の評価中に或る種の “副作用” が発生しないことを保証するためのようです．
            }ので，`fact/1` はさらに以下のような小慣れた実装に書き換えることができます：

            \d-code(```
              fact(N) -> fact(1, N).

              fact(Acc, N) when N =< 1 -> Acc;
              fact(Acc, N)             -> fact(Acc * N, N - 1).
            ```);%

            こうして定義した `fact/1` は，モジュール外から使うときは以下のように呼び出します：

            \d-code(```
              -module(some_external_module).
              -export([main/0]).

              main() -> calc:fact(6).
            ```);%
          }
          +p{\REMAINS{アトムについて}}
        >
        +subsection{並行処理の定式化}<
          +p{
            前述の通り，
            Erlangは並行処理や分散による並列処理を得意とする計算機言語で，
            特に並行や分散の処理は組み込み函数や専用の制御構文といった言語機能としてサポートされているのが特徴です．
          }
          +p{
            \REMAINS{spawn，send, receiveについて記載}
          }
        >
        +subsection{OTP Design Principlesについて}<
          +p{
            並行処理がどのように実現されているかは前節で紹介しましたが，
            実際には逐一 `spawn` や `!` や `receive` といった比較的低級な送受信の実装を直接記述する必要はなく，
            \dfn{OTP}（\dfn{Open Telecom Platform}）と呼ばれるライブラリ群を使って並行処理を実現することが多いです．
            OTPは並行処理，とりわけ可用性の追求を見越した並行処理に於いて共通の典型的なパターンを抽出したライブラリで，
            とりわけ `gen_server` モジュールと `supervisor` モジュールを利用することがほとんどです．
          }
          +subsubsection{`gen_server` モジュール}<
            +p{\REMAINS{gen_serverについて}}
          >
          +subsubsection{監視ツリーと `supervisor` モジュール}<
            +p{\REMAINS{監視ツリーとsupervisorについて}}
          >
        >
      >
      +section{Sesterlの開発動機}<
        +subsection{型システムの必要性}<
          +p{
            ここまで前提知識としてErlangの解説をしてきましたが，ここからようやくSesterlの話です．
            Sesterlの開発の動機となったErlangでの不満な点を挙げるなら，
            まずなんといってもErlangプログラムには事実上静的に型がつかないことです．
            Erlangには（既に脚註で触れたように）\dfn{Dialyzer}という型検査器がありますが，
            この型検査器の元になっている\dfn{success typing} \cite[`LindahlSagonas2006`];という体系は
            謂わば後づけ的にErlangに型システムを導入する都合で
            健全性を志向していない型システムのため，
            型検査に通っても実行時にはごく普通に（健全な型システムがあれば弾けそうな，形式のミスマッチによる）エラーが出ます．
          }
          +p{
            実行時に形式の不整合でエラーが出る可能性が機械的に排除できないことそれ自体も一応厄介な点ではありますが，
            それはまあテストの水準で比較的潰せるのでよいとして，
            型がつかないことで真に厄介なのは，それが修正やリファクタリングを極めて困難にする点にあります．
            健全性を満たす型システムの備わった言語なら，例えば或る函数定義の引数や戻り値の形式を変えたら
            それに伴ってその函数を使っている箇所全てで型検査時にエラーが出るようになり，
            そのエラーに従えば網羅的に修正できるのですが，健全性を満たす型システムのない状況だとそのような修正が機械的には補助されず，
            基本的には人力で修正すべき箇所を探し当てる（か或いは旧来の形式も後方互換性のためにサポートし続ける）羽目になってしまいがちです．
            一応その函数に対応するテストをしっかり用意できていればテストが落ちることによって確認できますが，
            テストも人間が用意するものなので網羅されている保証はありませんし，
            型のつかない言語で走らせたテストの失敗は型検査のエラーに比べると何が原因で失敗しているのかが
            些細な形式のミス（例えばどこかで1要素のリスト `[expr]` にすべきところにその要素 `expr` だけを書いてしまっているとか，
            或いは `{{x, y}, z}` とすべきところを `{x, {y, z}}` と書いてしまっているなど）に対して
            あまり解りやすい結果になるとは言えない傾向が顕著で，
            原因を特定して修正するのにかなりの労力を要してしまう状況によく見舞われます．
          }
          +p{
            こうした不満をバッサリ解決しつつ，並行処理が得意というErlangの利点を活かしてプログラムを書きたいというのが
            Erlangに（健全性を満たす）型システムを用意する最大の動機です．
          }
        >
        +subsection{Sesterlの目的と要件}<
          +p{
            さて，前節では単に型をつけたい旨を説明しましたが，
            自分が何を欲しがっているのかという目的の詳細を詰めると以下のようになりました\footnote{
              実際には開発当初から明瞭な言語化をしていたわけではなく，
              おおよそこうしたいと思って設計・実装しているうちに少しずつ煮詰まってきた目的と要件ではあります．
              今後の進展によってさらに変わることも勿論あるだろうと思います．
            }：

            \listing{
              * 既にErlangで書かれているプログラムをSesterlから利用しやすくするために，
                かつ既にErlangで書かれているプログラムを段階的にSesterlに移植していけるように，わかりやすいFFIを実現したい．

              * Erlangらしいアーキテクチャをそのまま書けるようにしたい．
                特にOTPライブラリはそれ自体には手を加えずにSesterl側から実装をできるだけ自然な形で利用できるようにしたい．

              * 函数の引数がやたらと増えても，どの引数がどうやって与えられるのかをなるべく捉えやすいようにしたい．

              * `spawn`，`!`，`receive` などの低級な通信もできるだけErlangの意味論に近い形で実現したい．

              * 例外はひとまずキャッチしないことを前提にしたい．

              * ビヘイビアなどによって依存関係が逆転することもあるので，
                Erlang側からもSesterlで実装された函数を簡単に呼べるようにしたい．

              * むやみに通信を起こすプログラムができあがってしまうスパゲティ化を防ぐために，
                純粋な計算と並行処理が発生する計算とを型の水準で区別できるようにしたい．
                また，可能なら “送受信の振舞い” も型の水準で表現できるようにしたい．
            }%
          }
          +p{
            こうした目的設定をうけて，要件を以下のようにすることとしました：

            \listing{
              * 基本的にはML風の言語設計とする．

              * FFIでの函数定義や使用のわかりやすさのため，ML系言語やHaskellのような部分適用は導入せず，
                函数はアリティをもつことにする．

              * 函数の引数の形式としては通常の引数のほかにラベルつき必須引数とラベルつきオプション引数を用意する．

              * OTPライブラリを型の水準で自然に定式化するために，ファンクタをもつモジュールシステムを導入する．

              * 通信が発生する計算はモナドでくるむようにし，
                各並行処理ないしプロセスは “自分がどんな型のメッセージを受け取れるか” の情報をトラックする．
                これを用いて `spawn`，`!`，`receive` 相当の言語機能に型をつける．
                可能なら\dfn{session type} \cite[`Honda1993`];や
                \dfn{multiparty session type} \cite[`HondaYoshidaCarbone2008`];を備えつける．
            }%
          }
        >
        +subsection{他のAltErlang言語}<
          +p{
            やはり人間皆似たことを考えるのか，
            同様の動機でErlangに型をつけようとして創られた言語はSesterl以外にもいくつかあります：

            \listing{
            * \dfn{Alpaca} \cite[`Alpaca`];
              ** OCamlやElmに近い構文と意味論をもち，
                 各プロセスがどんな型のメッセージを受け取れるかの情報を静的に検査することができます．
            * \dfn{Gleam} \cite[`Gleam`];
              ** Rust風の構文と意味論をもつAltErlangです．函数はアリティをもち，ラベルつき引数などの機能ももっています．
                 メッセージにはコア言語では型をつけない方針で，ライブラリの水準で型つけを実現する方針のようです．
                 2021年11月現在非常に精力的に開発されており，つい最近JavaScriptバックエンドも実装されたようです．
            * \dfn{Caramel} \cite[`Caramel`];
              ** OCaml互換の構文で開発されているものです．
                 PIDはメッセージの型をパラメータにとりますが，モナドによる純粋・並行の区別はないようです．
            * \dfn{Hamler} \cite[`Hamler`];
              ** Haskell風の構文と意味論をもつAltErlangです．型クラスを備えていたりします．
                 並行処理に関するモナドがありますが，メッセージの型をパラメータにとるわけではないようです．
                 また，OTPライブラリのビヘイビアは型クラスで定式化されているようです．
            }%
          }
          +p{
            Sesterlの開発を構想した当時，Alpacaと（当時の）Gleamがどんな言語であるか試したのですが，
            当時の自分は特にコア言語の水準でメッセージに型をつけて将来的にsession typeを入れることを重視していたので，
            これらとは別に新たに開発を開始することとしました．
          }
          +p{
            1年半ほど開発して，メッセージに対する型つけも簡潔かつ或る程度便利なものになりましたが，
            session typeは結局それほど強い必要性を感じることがなかったため今に至るまで入っておらず，
            結果的には（後で触れますが）OTPライブラリを型つけするためのF-ing Modulesに基づくモジュールシステムが
            とりわけ顕著な独自性となりました．
          }
        >
      >
      +section{Sesterlの言語設計}<
        +subsection{基礎的な言語機能}<
          +subsubsection{基本的な構文}<
            +p{
              まず基本的な構文は以下の例で一目瞭然かと思います：

              \d-code(```
                module Calc :> sig
                  val fact : fun(int) -> int
                  val sum : fun(list<int>) -> int
                  val id<$a> : fun($a) -> $a
                  val swap<$a, $b> : fun({$a, $b}) -> {$b, $a}
                  val have_same_length<$a, $b> : fun(list<$a>, list<$b>) -> bool
                end = struct
                  open Stdlib

                  val fact(n) =
                    let rec aux(acc, n) =
                      if n <= 0 then acc else aux(n * acc, n - 1)
                    in
                    aux(1, n)

                  val sum(ns) =
                    List.foldl(fun(acc, n) -> acc + n end, 0, ns)

                  val id(x) = x

                  val swap({x, y}) = {y, x}

                  val rec have_same_length<$a, $b>(xs : list<$a>, ys : list<$b>) : bool =
                    case {xs, ys} of
                    | {[], []}                 -> true
                    | {_ :: xtail, _ :: ytail} -> have_same_length(xtail, ytail)
                    | _                        -> false
                    end
                end
              ```);%
              \d-code(```
                require Calc

                module SomeModule = struct
                  val main() = Calc.sum([3, 1, 4, 1, 5, 9, 2])
                end
              ```);

              構文はおおよそML系のものを蹈襲していますが，以下のような特徴があります：

              \listing?:(true){
                * ソースコードのファイルは1つのモジュールの束縛
                  `module` ${X} `= struct` ${\ldots} `end`
                  であり，シグネチャが必要ならモジュール名の直後に
                  `:> sig` ${\ldots} `end`
                  と追記することができる．

                * ファイルの先頭に
                  \no-break-latin{`require` ${X}}
                  と書くことで同一パッケージ中の別ファイルであるモジュール ${X} を読み込める．
                  別パッケージが提供するモジュールは，設定ファイル `sesterl.yaml` に記載しておくと
                  どこでも使えるようになる．
                  例えば上記の例では `Stdlib` が別のパッケージに由来するモジュールで，
                  `open Stdlib` で中身が取り出されているので少しわかりにくいが，
                  `Stdlib.List.foldl` が使われている．

                * ストラクチャのメンバとなる（つまり `struct` ${\ldots} `end` 直下の）大域的な束縛は
                  `val` で始め，函数内の局所的な束縛は `let` で行なう．
                  後者は函数のほかに
                  \no-break-latin{`let n = 42 in` ${\ldots}}
                  のように函数でない値も当然束縛できるし，またパターンも
                  \no-break-latin{`let {x, _} = pair in` ${\ldots}}
                  のように使えるが，前者は函数しか束縛できない\footnote{
                    これは後述しますがErlangのモジュール中では函数しか定義できないことに由来します．
                  }．（相互）再帰函数を定義したい場合は
                  `val rec` \no-break-latin{${f_1}`(`${\ldots}`) =` ${e_1}}
                  `and` ${\ldots}
                  `and` \no-break-latin{${f_n}`(`${\ldots}`) =` ${e_n}}
                  のように記述する．`let` の場合も同様．

                * 前述の通り函数はCurry化されないため，函数の型は
                  （一般的な \no-break-latin{${\tau'} `->` ${\tau}} などではなく）
                  \no-break-latin{`fun(`${\tau_1}`,` ${\ldots}`,` ${\tau_n}`) ->` ${\tau}}
                  の形式であり，例えば
                  \no-break-latin{`fun(`${\tau_1}`,` ${\tau_2}`) ->` ${\tau}}
                  は
                  \no-break-latin{`fun(`${\tau_1}`) -> fun(`${\tau_2}`) ->` ${\tau}}
                  とは異なる型である．適用も例えば
                  `List.foldl f i xs`
                  ではなく
                  `List.foldl(f, i, xs)`
                  などと書く．やはり
                  ${e}`(`${e_1}`,` ${e_2}`)`
                  と
                  ${e}`(`${e_1}`)(` ${e_2}`)`
                  とは（具象構文としてだけでなく）抽象構文として異なる．

                * 具象構文上型コンストラクタは前置で，例えば（`int list` ではなく）`list<int>` と記述する．
                  複数の型引数がある場合は `result<int, error>` のようにコンマ区切り．
                  高階の型コンストラクタはサポートしていない．

                * 型註釈を書かずともlet多相での主要型を推論してくれる．
                  再帰函数については，型註釈を全ての引数と戻り値について書いていれば多相再帰も受理する．

                * 直積型は
                  \no-break-latin{`{`${\tau_1}`,` ${\ldots}`,` ${\tau_n}`}`}
                  の形で書き，組（タプル）はErlangと同様に
                  \no-break-latin{`{`${e_1}`,` ${\ldots}`,` ${e_n}`}`}
                  の形で書く．
                  1要素だけの直積型 `{`${\tau}`}` と組 `{`${e}`}` もいくつかの用途のために用意されている．

                * リストの式は
                  \no-break-latin{`[`${e_1}`,` ${\ldots}`,` ${e_n}`]`}
                  とコンマ区切りで書くほか，通常のいわゆるコンスセルの書き方
                  \no-break-latin{${e_1} `::` ${e_2} `::` ${\ldots} `::` ${e_n} `:: []`}
                  も可能．パターンでも同様．

                * 函数定義や函数抽象の引数で（単一の変数に限らず）パターンを使うことができる．

                * 型変数は `$a` のようにドル記号が接頭辞としてつく．
                  全称量化は `<$a, $b>` のようにコンマ区切りで型変数を並べて `<` と `>` で括り，
                  束縛される函数名の直後に書く．シグネチャ中の宣言だけでなく，
                  \no-break-latin{`val have_same_length<$a, $b>(`${\ldots}`) =` ${\ldots}}
                  のように実装中の型註釈でもそのように書くことができる．
              }%
            }
          >
          +subsubsection{列多相によるレコード}<
            +p{\REMAINS{レコード}}
          >
          +subsubsection{ラベルつき引数}<
            +p{\REMAINS{ラベルつき必須/オプション引数}}
          >
          +subsubsection{FFI}<
            +p{\REMAINS{FFI}}
          >
          +subsubsection{並行処理}<
            +p{\REMAINS{並行処理}}
          >
        >
        +subsection{SesterlをOTP Design Principlesに適合させるために必要だった言語機能たち}<
          +p{\REMAINS{ファンクタ，static interpretation，future workとして再帰モジュール}}
        >
      >
      +section{天九のルール}<
        +p{\REMAINS{天九のルールを簡単に紹介}}
      >
      +section{ゲームサーバとクライアントの設計}<
        +p{\REMAINS{設計の話．これは直接Erlang/OTPで実装する場合でも全く同じ}}
      >
      +section{まとめ}<
        +p{\REMAINS{まとめ}}
      >
    >
  >

end
