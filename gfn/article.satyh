@require: itemize
@require: code
@require: base/image

@require: class-yabaitech/yabaitech

module Gfn : sig

  val article : block-text

end = struct

  let bibliography = []

  let article = '<
    +chapter ?:(`gfn-article`)(|
        bibliography  = bibliography;
        title         = {自作言語でオンラインゲームを実装した話};
        author        = {gfn};
        title-for-toc = None;
        subtitle      = None;
    |)<
      +section{はじめに}<
        +p{
          \dfn{Sesterl}（セスタール）という自作言語で\dfn{天九Online}というオンラインゲームを実装した話を報告したいと思います．
          Sesterlは2020年4月頃から筆者が開発している計算機言語で，
          簡単に言えば\dfn{Erlang}という既存の計算機言語に静的な型システムを搭載することを目的としているものです．
          要するに，JavaScriptに対するTypeScript，PureScript，Elm，ReScriptといった立ち位置の言語を
          Erlangに関して実装しようという試みであり，AltJSになぞらえて言えば
          AltErlangという具合の言語です．
          Erlangはアクターモデルに基づいた意味論をもち，並行処理や分散処理に関する機能がビルトインで提供されているなど
          並行並列に特に強みをもつ言語ですが，静的に型がつかず\footnote{
            一応\dfn{success typing}という型システムおよびその型検査器の実装である\dfn{Dialyzer}がありますが，
            後づけで導入されたものであって健全性 (soundness) を満たすことを志向した型システムではなく，
            型がつくことによって保証できるプログラムの性質はかなり弱い主張に留まっており，
            型検査に通っても実行時に形式の不整合でエラーが起きることはごく普通にあります．
          }，実装の正しさを保証したりリファクタリングを施したりするのにかなり苦労する言語です．
          これを解決することを企図して開発しているのがSesterlというわけです．
        }
        +p{
          1年ほど開発を続け，Sesterlも或る程度成熟してきたのですが，
          「そうはいっても本当に実用に堪えるものになっているだろうか」という疑問が湧き，
          また丁度数年前からいつか実装したいと思っていたゲームがあったので，
          2021年5月末頃からSesterlを用いて実際に稼働するオンラインゲームのサーヴァサイドを実装してみることにしました．
          そうしてひとまず動作するようになったのが天九Onlineというゲームです．
          天九Onlineは\dfn{天九}または\dfn{打天九}という中国大陸や台湾などで古くから遊ばれている既存の卓上ゲームを実装したもので，
          これは\dfn{天九牌}という32枚1セットの牌を使ったトリックテイキングゲーム\footnote{
            1ゲームが複数の\dfn{トリック} (trick) という小さい勝負からなり，
            各トリックでは各プレイヤーが1回ずつ所定の順番で手札から場に札を出して全員分出揃ったらそのトリックの勝敗を決め，
            勝った人が次のトリックの最初の札の提示を担う，ということを繰り返して
            何らかの条件でゲーム全体の勝敗を決める，という形式のゲームを
            トリックテイキングゲームと言います．
            いわゆるトランプを使って遊ぶトリックテイキングゲームの例としてはハーツやナポレオンなどが有名です．
          }です．
          天九のルールについても簡単に紹介しつつ，実際に卓上ゲームが対戦できる小さいサーヴァをどのように設計・実装したか紹介します．
        }
        +p{
          趣味で言語処理系を実装する方は世の中に数多くいらっしゃると思いますが，
          大方の自作言語は制作者自身の言語処理系への理解のために創られたものであったりして，
          実用可能な水準まで作り込む経験談はあまり見かけないように思います．
          実用を目的としてドッグフーディングで自作言語を作り込むのはチマチマとした改善を継続する地味ながら執念を要する開発ですが，
          実際に自作言語のおかげで（そうでない場合よりも）高い生産性を発揮できていることが実感できたときの欣快はひとしおです．
          そんなわけで，ちょっと自己満足的な側面も含んでしまいますが，
          自作言語を実用してゲームを実装しつつ言語もドッグフーディングで改善していった過程を簡単に共有できればと思い，記事にしました．
        }
        +subsection{想定する前提知識}<
          +listing{
            * 静的型つきの函数型プログラミングに関する基礎的な理解．
              例えばHaskellやOCamlでプログラムを書いたことがある，単純型の型つけ規則を眺めたことがあるなど．
            * Webアプリケーションの仕組みに対する基礎的な理解．
          }
        >
      >
      +section{Erlangの簡単な解説}<
        +p{
          SesterlはErlangという既存の言語をラップするために開発されました．
          では元々のErlangとはどんな言語なのでしょうか？
          おそらく「Erlangという名前くらいは聞いたことがあるが使ったことは全くない」という読者も多いかと思うので，
          簡単にErlangの構文や意味論について説明します．
          とはいえErlangに入門するための文書は公式ドキュメントはもとより非公式のものもいくらでもあるはずなので，
          ここで懇切丁寧に解説するつもりはなく，
          全く読み書きしたことのない人に最低限おおよそどんな言語なのかの雰囲気を掴んでもらうために
          ごく簡単にかいつまんで記載します．
        }
        +subsection{基本的な構文と意味論}<
          +p{
            前述の通り，Erlangの意味論はいわゆる函数型言語のそれを基調としており，
            例えば階乗函数 `fact` や整数のリストを受け取りその総和を返す函数 `sum` は以下のように書けます：

            \d-code(```
              -module(sample_module).
              -export([fact/1, sum/1]).

              fact(N) ->
                  case N =< 1 of
                      true  -> 1;
                      false -> N * fact(N - 1)
                  end.

              sum(Ns) ->
                  lists:foldl(fun(N, Acc) -> N + Acc end, 0, Ns).
            ```);%

            変数の名前は大文字始まり，トップレヴェルで定義される函数の名前は小文字始まり\footnote{
              トップレヴェルの函数の名前は正確には後述のアトムの形式と一致し，単引用符で括って一般の文字列が名前として使えます．
            }，函数定義の終わりにはピリオドを打つ，
            `case` 式によるパターンマッチングは枝の区切りにセミコロンを使う，
            他のモジュールの函数を呼び出すには `lists:foldl` などとモジュール名と函数名をコロンで繋いで書くなど
            かなりアクの強いProlog風の具象構文をもっていますが，
            Lisp諸方言，Haskell，OCamlあたりに親しみのある方なら
            函数定義についてはわりと構文から意図するところが推測できるのではないかと思います．
            1行目はこのソースファイルが記述するモジュールの名前を，
            2行目はソースファイル内で定義されている函数のうちどれを公開するか（＝モジュール外から呼び出せるようにするか）を記載しています．
            `fact/1` が階乗函数の名前で，`/1` はアリティ（＝何個の引数をとるか）を表します．
            アリティが名前の一部なのは，函数が（HaskellやOCamlなどと違い）Curry化されておらずアリティをもち，
            かつ同一の名前で異なるアリティの函数は全く別の（たまたま名前が同じ）函数として扱うことを許す言語設計になっているためです．
            特に，アリティの異なる補助函数は同名にする慣習があり，
            上記の `fact/1` を末尾呼び出し再帰になるように書き換えるときには以下のように
            補助函数を `fact/2` としたりします：

            \d-code(```
              fact(N) ->
                  fact(1, N).

              fact(Acc, N) ->
                  case N =< 1 of
                      true  -> Acc;
                      false -> fact(Acc * N, N - 1)
                  end.
            ```);%

            なお，パターンマッチングやそれによる分岐は函数の引数でも行なえて，
            また `when` 節によりマッチする条件を加えることができる\footnote{
              ただし，`when` 節の中では限られた組み込み函数しか使えないように制限されています．
              これは `when` 節の評価中に或る種の “副作用” が発生しないことを保証するためのようです．
            }ので，`fact/1` はさらに以下のような小慣れた実装に書き換えることができます：

            \d-code(```
              fact(N) ->
                  fact(1, N).

              fact(Acc, N) when N =< 1 -> Acc;
              fact(Acc, N)             -> fact(Acc * N, N - 1).
            ```);%

            こうして定義した `fact/1` は，モジュール外から使うときは以下のように呼び出します：

            \d-code(```
              -module(some_external_module).
              -export([main/0]).

              main() ->
                  sample_module:fact(6).  % => 720
            ```);%
          }
        >
        +subsection{並行処理の定式化}<
          +p{
            前述の通り，
            Erlangは並行処理や分散による並列処理を得意とする計算機言語で，
            特に並行や分散の処理は組み込み函数や専用の制御構文といった言語機能としてサポートされているのが特徴です．
          }
          +p{
            \REMAINS{spawn，send, receiveについて記載}
          }
        >
        +subsection{OTP Design Principlesについて}<
          +p{\REMAINS{gen_server，supervisor，監視ツリーについて}}
        >
      >
      +section{Sesterlの開発動機}<
        +p{
          \REMAINS{静的に型がつかない旨を記述}
        }
        +p{
          \REMAINS{Sesterlの開発動機}
        }
      >
      +section{Sesterlの言語設計}<
        +subsection{基本的な構文}<
          +p{\REMAINS{定義，ストラクチャ，FFIなど}}
        >
        +subsection{SesterlをOTP Design Principlesに適合させるために必要だった言語機能たち}<
          +p{\REMAINS{ファンクタ，static interpretation，future workとして再帰モジュール}}
        >
      >
      +section{天九のルール}<
        +p{\REMAINS{天九のルールを簡単に紹介}}
      >
      +section{ゲームサーバとクライアントの設計}<
        +p{\REMAINS{設計の話．これは直接Erlang/OTPで実装する場合でも全く同じ}}
      >
    >
  >

end
