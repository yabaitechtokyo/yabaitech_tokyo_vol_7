@require: itemize
@require: code
@require: base/image

@require: class-yabaitech/yabaitech

module Gfn : sig

  val article : block-text

end = struct

  let bibliography = []

  let article = '<
    +chapter ?:(`gfn-article`)(|
        bibliography  = bibliography;
        title         = {自作言語でオンラインゲームを実装した話};
        author        = {gfn};
        title-for-toc = None;
        subtitle      = None;
    |)<
      +section{はじめに}<
        +p{
          \dfn{Sesterl}（セスタール）という自作言語で\dfn{天九Online}というオンラインゲームを実装した話を報告したいと思います．
          Sesterlは2020年4月頃から筆者が開発している計算機言語で，
          簡単に言えばErlangに静的な型システムを搭載することを目的としているものです．
          要するに，JavaScriptに対するTypeScript，PureScript，Elm，ReScriptといった立ち位置の言語を
          Erlangに関して実装しようという試みであり，AltJSになぞらえて言えば
          AltErlangという具合の言語です．
          Erlangはアクターモデルに基づいた意味論をもち，並行処理や分散処理に関する機能がビルトインで提供されているなど
          並行並列に特に強みをもつよく知られた言語ですが，
        }
        +p{
          1年ほど開発を続け，Sesterlも或る程度成熟してきたのですが，
          「そうはいっても本当に実用に堪えるものになっているだろうか」という疑問が湧き，
          また丁度数年前からいつか実装したいと思っていたゲームがあったので，
          2021年5月末頃からSesterlを用いて実際に稼働するオンラインゲームのサーヴァサイドを実装してみることにしました．
          そうしてひとまず動作するようになったのが天九Onlineというゲームです．
          天九Onlineは\dfn{天九}または\dfn{打天九}という中国大陸や台湾などで古くから遊ばれている既存の卓上ゲームを実装したもので，
          これは\dfn{天九牌}という32枚1セットの牌を使ったトリックテイキングゲーム\footnote{
            1ゲームが複数の\dfn{トリック} (trick) という小さい勝負からなり，
            各トリックでは各プレイヤーが1回ずつ所定の順番で手札から場に札を出して全員分出揃ったらそのトリックの勝敗を決め，
            勝った人が次のトリックの最初の札の提示を担う，ということを繰り返して
            何らかの条件でゲーム全体の勝敗を決める，という形式のゲームを
            トリックテイキングゲームと言います．
            いわゆるトランプを使って遊ぶトリックテイキングゲームの例としてはハーツやナポレオンなどが有名です．
          }です．
          天九のルールについても簡単に紹介しつつ，実際に卓上ゲームが対戦できる小さいサーヴァをどのように設計・実装したか紹介します．
        }
        +p{
          趣味で言語処理系を実装する方は世の中に数多くいらっしゃると思いますが，
          大方の自作言語は制作者自身の言語処理系への理解のために創られたものであったりして，
          実用可能な水準まで作り込む経験談はあまり見かけないように思います．
          実用を目的としてドッグフーディングで自作言語を作り込むのはチマチマとした改善を継続する地味ながら執念を要する開発ですが，
          実際に自作言語のおかげで（そうでない場合よりも）高い生産性を発揮できていることが実感できたときの欣快はひとしおです．
          そんなわけで，ちょっと自己満足的な側面も含んでしまいますが，
          自作言語を実用してゲームを実装しつつ言語もドッグフーディングで改善していった過程を簡単に共有できればと思い，記事にしました．
        }
      >
      +section{Sesterlの概要と開発動機}<
        +p{
          まずはSesterlのターゲット言語であるErlangの紹介を簡単にします．
          おそらく，Erlangという名前くらいは聞いたことがあるが使ったことは全くない，という方が殆どなのではないかと思います．
          Erlangは並行処理や分散による並列処理を得意とする計算機言語で，
          特に並行や分散の処理は組み込み函数や専用の制御構文といった言語機能としてサポートされているのが特徴です．
          Erlangが具体的にどんな構文や意味論をもつ言語なのかについては
          \ref-section(`sec:gfn:brief-introduction-to-erlang`);で簡単に解説します．
        }
        +p{
          \REMAINS{静的に型がつかない旨を記述}
        }
        +p{
          \REMAINS{Sesterlの開発動機}
        }
      >
      +section?:(`sec:gfn:brief-introduction-to-erlang`){Erlangの簡単な解説}<
        +subsection{基本的な構文}<
          +p{
            前述の通り，Erlangの意味論の基本はいわゆる函数型言語らしいもので，例えば階乗函数は以下のように書けます：

            \d-code(```
              -module(sample_module).
              -export([fact/1]).

              fact(N) ->
                  case N =< 1 of
                      true  -> 1;
                      false -> N * fact(N - 1)
                  end.
            ```);%

            Lisp諸方言，Haskell，OCamlあたりに親しみのある方なら，
            函数定義 `fact(N) -> ….` の部分はわりと構文から意図するところが推測できるのではないかと思います．
            1行目はこのソースファイルが記述するモジュールの名前を，
            2行目はソースファイル内で定義されている函数のうちどれを公開するか（＝モジュール外から呼び出せるようにするか）を記載しています．
            `fact/1` が階乗函数の名前で，`/1` はアリティ（＝何個の引数をとるか）を表します．
            アリティが名前の一部なのは，函数が部分適用を許しておらず，かつ同一の名前で異なるアリティの函数は
            全く別の（たまたま名前が同じ）函数として扱う言語設計になっているためです．
          }
          +p{
            \REMAINS{もう少しだけ紹介}
          }
        >
        +subsection{並行処理の定式化}<
          +p{
            \REMAINS{spawn，send, receiveについて記載}
          }
        >
        +subsection{OTP Design Principlesについて}<
          +p{\REMAINS{}}
        >
      >
      +section{Sesterlの言語設計}<
        +subsection{基本的な構文}<
          +p{\REMAINS{定義，ストラクチャ，FFIなど}}
        >
        +subsection{SesterlをOTP Design Principlesに適合させるために必要だった言語機能たち}<
          +p{\REMAINS{ファンクタ，static interpretation，future workとして再帰モジュール}}
        >
      >
      +section{天九のルール}<
        +p{\REMAINS{天九のルールを簡単に紹介}}
      >
      +section{ゲームサーバとクライアントの設計}<
        +p{\REMAINS{設計の話．これは直接Erlang/OTPで実装する場合でも全く同じ}}
      >
    >
  >

end
