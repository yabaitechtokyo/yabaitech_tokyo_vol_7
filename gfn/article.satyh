@require: itemize
@require: code
@require: base/image

@require: class-yabaitech/yabaitech

module Gfn : sig

  val article : block-text

end = struct

  let-inline ctx \no-break-latin it =
    let pads = (0pt, 0pt, 0pt, 0pt) in
    let deco _ _ _ _ = [] in
    script-guard Latin (inline-frame-outer pads deco (read-inline ctx it))

  let bibliography = [
    (`GasterJones1996`, Article(|
      author = {| Benedict R. Gaster | Mark P. Jones |};
      title = {A polymorphic type system for extensible records and variants};
      journal = {Technical Report NOTTCS-TR-96-3};
      volume = None;
      number = None;
      pages = (1, 12);
      year = 1996;
    |));
    (`Honda1993`, Article(|
      % https://doi.org/10.1007/3-540-57208-2_35
      author = {| Kohei Honda |};
      title = {Types for dyadic interaction};
      journal = {Lecture Notes in Computer Science (CONCUR’93)};
      volume = Some(715);
      number = None;
      pages = (509, 523);
      year = 1993;
    |));
    (`HondaYoshidaCarbone2008`, InProceedings(|
      % https://doi.org/10.1145/1328438.1328472
      author = {| Kohei Honda | Nobuko Yoshida | Marco Carbone |};
      title = {Multiparty asynchronous session types};
      booktitle = {
        Proceedings of the 35th Annual ACM SIGPLAN-SIGACT Symposium on
        Principles of Programming Languages
      };
      series = Some({POPL’08});
      volume = None;
      number = None;
      pages = (273, 284);
      year = 2008;
    |));
    (`LindahlSagonas2006`, InProceedings(|
      % https://it.uu.se/research/group/hipe/papers/succ_types.pdf
      author = {| Tobias Lindahl | Konstantinos Sagonas |};
      title = {Practical type inference based on success typings};
      booktitle = {
        Proceedings of the 8th ACM SIGPLAN International Conference on
        Principles and Practice of Declarative Programming};
      series = Some({PPDP’06});
      volume = None;
      number = None;
      pages = (167, 178);
      year = 2006;
    |));
    (`Caramel`, WebSite(|
      author = {| Leandro Ostera et al. |};
      title = {Caramel};
      url = `https://github.com/AbstractMachinesLab/caramel`;
      year = 2020;
    |));
    (`Hamler`, WebSite(|
      author = {| Feng Lee et al. |};
      title = {Hamler};
      url = `https://github.com/hamler-lang/hamler`;
      year = 2019;
    |));
    (`Ohori1995`, Article(|
      author = {| Atsushi Ohori |};
      title = {A polymorphic record calculus and its compilation};
      journal = {ACM Transactions on Programming Languages and Systems};
      volume = Some(17);
      number = Some({6});
      pages = (844, 895);
      year = 1995;
    |));
    (`Alpaca`, WebSite(|
      author = {| Jeremy Pierre et al. |};
      title = {Alpaca};
      url = `https://github.com/alpaca-lang/alpaca`;
      year = 2016;
    |));
    (`Gleam`, WebSite(|
      author = {| Louis Pilfold et al. |};
      title = {Gleam};
      url = `https://github.com/gleam-lang/gleam`;
      year = 2018;
    |));
    (`RossbergRussoDreyer2014`, Article(|
      author = {| Andreas Rossberg | Claudio Russo | Derek Dreyer |};
      title = {F-ing modules};
      journal = {Journal of Functional Programming};
      volume = Some(24);
      number = Some({5});
      pages = (529, 607);
      year = 2014;
    |));
  ]

  let article = '<
    +chapter ?:(`gfn-article`)(|
        bibliography  = bibliography;
        title         = {自作言語でオンラインゲームを実装した話};
        author        = {gfn};
        title-for-toc = None;
        subtitle      = None;
    |)<
      +section{はじめに}<
        +p{
          \dfn{Sesterl}（セスタール）という自作言語で\dfn{天九Online}というオンラインゲームを実装した話を報告したいと思います．
          Sesterlは2020年4月頃から筆者が開発している計算機言語で，
          簡単に言えば\dfn{Erlang}という既存の計算機言語に静的な型システムを搭載することを目的としているものです．
          要するに，JavaScriptに対するTypeScript，PureScript，Elm，ReScriptといった立ち位置の言語を
          Erlangに関して実装しようという試みであり，AltJSになぞらえて言えば
          AltErlangという具合の言語です．
          Erlangはアクターモデルに基づいた意味論をもち，並行処理や分散処理に関する機能がビルトインで提供されているなど
          並行並列に特に強みをもつ言語ですが，静的に型がつかず\footnote{
            一応\dfn{success typing} \cite[`LindahlSagonas2006`];という型システム
            およびその型検査器の実装である\dfn{Dialyzer}がありますが，
            後づけで導入されたものであって健全性 (soundness) を満たすことを志向した型システムではなく，
            型がつくことによって保証できるプログラムの性質はかなり弱い主張に留まっており，
            型検査に通っても実行時に形式の不整合でエラーが起きることはごく普通にあります．
          }，実装の正しさを保証したりリファクタリングを施したりするのにかなり苦労する言語です．
          これを解決することを企図して開発しているのがSesterlというわけです．
        }
        +p{
          後々もう少し詳細に触れますが，Sesterlの型システムの概要を言うと，以下のようなものが備わっています：

          \listing{
            * \dfn{Damas–Milner多相}（いわゆるlet多相）およびその\dfn{Hindley–Milner型推論}
            * 列多相によるレコード型 \cite[`GasterJones1996`];
            * 函数のラベルつき必須引数，および列多相を利用したラベルつきオプション引数
            * \dfn{F-ing Modules} \cite[`RossbergRussoDreyer2014`];に基づく，ファンクタなどを扱えるモジュールシステム
              ** このモジュールシステムは特に `gen_server` や `supervisor` といった\dfn{OTPライブラリ}を型安全に
                 ラップするのに利用しています．
            * 純粋な計算と並行処理とを区別するためのモナド
            * Erlangで実装した函数に型註釈をつけてSesterl側で使えるようにするFFI
          }%
        }
        +p{
          1年ほど開発を続け，Sesterlも或る程度成熟してきたのですが，
          「そうはいっても本当に実用に堪えるものになっているだろうか」という疑問が湧き，
          また丁度数年前からいつか実装したいと思っていたゲームがあったので，
          2021年5月末頃からSesterlを用いて実際に稼働するオンラインゲームのサーバサイドを実装してみることにしました．
          そうして（不足を感じたら適宜Sesterlの方も拡張しつつ）ひとまず動作するようになったのが天九Onlineというゲームです．
          天九Onlineは\dfn{天九}または\dfn{打天九}という中国大陸や台湾などで古くから遊ばれている既存の卓上ゲームを実装したもので，
          これは\dfn{天九牌}という32枚1セットの牌を使ったトリックテイキングゲーム\footnote{
            概して次のような性質を満たすルールのゲームを\dfn{トリックテイキングゲーム}と言います：

            \listing{
              * 1ゲームが複数の\dfn{トリック}という小さい勝負からなる．
              * 最初はプレイヤー全員に同じ枚数の手札が渡されている．
              * 各トリックでは，最初の手番の人から順に各プレイヤーが1回ずつ手札から場に札を出し，
                全員分出揃ったらその出揃ったカードに基づいてそのトリックの勝敗を決める．
                勝った人が次のトリックの最初の手番となる．
              * トリックで場に出たカードのうちどれが勝つかの判定基準は，
                最初の手番のプレイヤーが出した札である\dfn{台札}によって変わる．
              * 最後のトリックが終わったら，
                それまでの各トリックでの勝敗などをもとに何らかの条件でゲーム全体の勝敗や得点の移動を決める．
            }%

            いわゆるトランプを使って遊ぶトリックテイキングゲームの例としては\dfn{ハーツ}や\dfn{ナポレオン}などが有名です．
          }です．
          天九のルールについても簡単に紹介しつつ，実際に卓上ゲームが対戦できる小さいサーバをどのように設計・実装したか紹介します．
        }
        +p{
          趣味で言語処理系を実装する方は世の中に数多くいらっしゃると思いますが，
          大方の自作言語は制作者自身の言語処理系への理解のために創られたものであったりして，
          実用可能な水準まで作り込む経験談はあまり見かけないように思います．
          実用を目的としてドッグフーディングで自作言語を作り込むのはチマチマとした改善を継続する地味ながら執念を要する開発ですが，
          実際に自作言語のおかげで（そうでない場合よりも）高い生産性を発揮できていることが実感できたときの欣快はひとしおです．
          そんなわけで，ちょっと自己満足的な側面も含んでしまいますが，
          自作言語を実用してゲームを実装しつつ言語もドッグフーディングで改善していった過程を簡単に共有できればと思い，記事にしました．
        }
        +subsection{想定する前提知識}<
          +listing{
            * 静的型つきの函数型プログラミングに関する基礎的な理解．
              ** 例えばHaskellやOCamlでプログラムを書いたことがある，単純型の型つけ規則を眺めたことがあるなど．
            * Webアプリケーションの仕組みに対する基礎的な理解．
              ** クライアント-サーバモデルという概念やHTTPの規格の概要を把握しているなど．
          }
        >
      >
      +section{Erlangの簡単な解説}<
        +p{
          SesterlはErlangという既存の言語をラップするために開発されました．
          では元々のErlangとはどんな言語なのでしょうか？
          おそらく「Erlangという名前くらいは聞いたことがあるが使ったことは全くない」という読者も多いかと思うので，
          簡単にErlangの構文や意味論について説明します．
          とはいえErlangに入門するための文書は公式ドキュメントはもとより非公式のものもいくらでもあるはずなので，
          ここで懇切丁寧に解説するつもりはなく，
          全く読み書きしたことのない人に最低限おおよそどんな言語なのかの雰囲気を掴んでもらうために
          ごく簡単にかいつまんで記載します．
        }
        +subsection{基本的な構文と意味論}<
          +p{
            前述の通り，Erlangの意味論はいわゆる函数型言語のそれを基調としており，
            例えば階乗函数 `fact` や整数のリストを受け取りその総和を返す函数 `sum` は以下のように書けます：

            \d-code(```
              -module(calc).
              -export([fact/1, sum/1]).

              fact(N) ->
                  case N =< 1 of
                      true  -> 1;
                      false -> N * fact(N - 1)
                  end.

              sum(Ns) ->
                  lists:foldl(fun(N, Acc) -> N + Acc end, 0, Ns).
            ```);%

            変数の名前は大文字始まり，トップレべルで定義される函数の名前は小文字始まり\footnote{
              トップレベルの函数の名前は正確には後述のアトムの形式と一致し，単引用符で括って一般の文字列が名前として使えます．
            }，函数定義の終わりにはピリオドを打つ，
            `case` 式によるパターンマッチングは枝の区切りにセミコロンを使う，
            他のモジュールの函数を呼び出すには `lists:foldl` などとモジュール名と函数名をコロンで繋いで書くなど
            かなりアクの強いProlog風の具象構文をもっていますが，
            Lisp諸方言，Haskell，OCamlあたりに親しみのある方なら
            函数定義についてはわりと構文から意図するところが推測できるのではないかと思います．
            1行目はこのソースファイルが記述するモジュールの名前を，
            2行目はソースファイル内で定義されている函数のうちどれを公開するか（＝モジュール外から呼び出せるようにするか）を記載しています．
            `fact/1` が階乗函数の名前で，`/1` はアリティ（＝何個の引数をとるか）を表します．
            アリティが名前の一部なのは，函数が（HaskellやOCamlなどと違い）Curry化されておらずアリティをもち，
            かつ同一の名前で異なるアリティの函数は全く別の（たまたま名前が同じ）函数として扱うことを許す言語設計になっているためです．
            特に，アリティの異なる補助函数は同名にする慣習があり，
            上記の `fact/1` を末尾呼び出し再帰になるように書き換えるときには以下のように
            補助函数を `fact/2` としたりします：

            \d-code(```
              fact(N) ->
                  fact(1, N).

              fact(Acc, N) ->
                  case N =< 1 of
                      true  -> Acc;
                      false -> fact(Acc * N, N - 1)
                  end.
            ```);%

            なお，パターンマッチングやそれによる分岐は函数の引数でも行なえて，
            また `when` 節によりマッチする条件を加えることができる\footnote{
              ただし，`when` 節の中では限られた組み込み函数しか使えないように制限されています．
              これは `when` 節の評価中に或る種の “副作用” が発生しないことを保証するためのようです．
            }ので，`fact/1` はさらに以下のような小慣れた実装に書き換えることができます：

            \d-code(```
              fact(N) -> fact(1, N).

              fact(Acc, N) when N =< 1 -> Acc;
              fact(Acc, N)             -> fact(Acc * N, N - 1).
            ```);%

            こうして定義した `fact/1` は，モジュール外から使うときは以下のように呼び出します：

            \d-code(```
              -module(some_external_module).
              -export([main/0]).

              main() -> calc:fact(6).
            ```);%
          }
          +p{\REMAINS{アトムについて}}
        >
        +subsection{並行処理の定式化}<
          +p{
            前述の通り，
            Erlangは並行処理や分散による並列処理を得意とする計算機言語で，
            特に並行や分散の処理は組み込み函数や専用の制御構文といった言語機能としてサポートされているのが特徴です．
          }
          +p{
            \REMAINS{spawn，send, receiveについて記載}
          }
        >
        +subsection{OTP Design Principlesについて}<
          +p{
            並行処理がどのように実現されているかは前節で紹介しましたが，
            実際には逐一 `spawn` や `!` や `receive` といった比較的低級な送受信の実装を直接記述する必要はなく，
            \dfn{OTP}（\dfn{Open Telecom Platform}）と呼ばれるライブラリ群を使って並行処理を実現することが多いです．
            OTPは並行処理，とりわけ可用性の追求を見越した並行処理に於いて共通の典型的なパターンを抽出したライブラリで，
            とりわけ `gen_server` モジュールと `supervisor` モジュールを利用することがほとんどです．
          }
          +subsubsection{`gen_server` モジュール}<
            +p{\REMAINS{gen_serverについて}}
          >
          +subsubsection{監視ツリーと `supervisor` モジュール}<
            +p{\REMAINS{監視ツリーとsupervisorについて}}
          >
        >
      >
      +section{Sesterlの開発動機}<
        +subsection{型システムの必要性}<
          +p{
            ここまで前提知識としてErlangの解説をしてきましたが，ここからようやくSesterlの話です．
            Sesterlの開発の動機となったErlangでの不満な点を挙げるなら，
            まずなんといってもErlangプログラムには事実上静的に型がつかないことです．
            Erlangには（既に脚註で触れたように）\dfn{Dialyzer}という型検査器がありますが，
            この型検査器の元になっている\dfn{success typing} \cite[`LindahlSagonas2006`];という体系は
            謂わば後づけ的にErlangに型システムを導入する都合で
            健全性を志向していない型システムのため，
            型検査に通っても実行時にはごく普通に（健全な型システムがあれば弾けそうな，形式のミスマッチによる）エラーが出ます．
          }
          +p{
            実行時に形式の不整合でエラーが出る可能性が機械的に排除できないことそれ自体も一応厄介な点ではありますが，
            それはまあテストの水準で比較的潰せるのでよいとして，
            型がつかないことで真に厄介なのは，それが修正やリファクタリングを極めて困難にする点にあります．
            健全性を満たす型システムの備わった言語なら，例えば或る函数定義の引数や戻り値の形式を変えたら
            それに伴ってその函数を使っている箇所全てで型検査時にエラーが出るようになり，
            そのエラーに従えば網羅的に修正できるのですが，健全性を満たす型システムのない状況だとそのような修正が機械的には補助されず，
            基本的には人力で修正すべき箇所を探し当てる（か或いは旧来の形式も後方互換性のためにサポートし続ける）羽目になってしまいがちです．
            一応その函数に対応するテストをしっかり用意できていればテストが落ちることによって確認できますが，
            テストも人間が用意するものなので網羅されている保証はありませんし，
            型のつかない言語で走らせたテストの失敗は型検査のエラーに比べると何が原因で失敗しているのかが
            些細な形式のミス（例えばどこかで1要素のリスト `[expr]` にすべきところにその要素 `expr` だけを書いてしまっているとか，
            或いは `{{x, y}, z}` とすべきところを `{x, {y, z}}` と書いてしまっているなど）に対して
            あまり解りやすい結果になるとは言えない傾向が顕著で，
            原因を特定して修正するのにかなりの労力を要してしまう状況によく見舞われます．
          }
          +p{
            こうした不満をバッサリ解決しつつ，並行処理が得意というErlangの利点を活かしてプログラムを書きたいというのが
            Erlangに（健全性を満たす）型システムを用意する最大の動機です．
          }
        >
        +subsection{Sesterlの目的と要件}<
          +p{
            さて，前節では単に型をつけたい旨を説明しましたが，
            自分が何を欲しがっているのかという目的の詳細を詰めると以下のようになりました\footnote{
              実際には開発当初から明瞭な言語化をしていたわけではなく，
              おおよそこうしたいと思って設計・実装しているうちに少しずつ煮詰まってきた目的と要件ではあります．
              今後の進展によってさらに変わることも勿論あるだろうと思います．
            }：

            \listing{
              * 既にErlangで書かれているプログラムをSesterlから利用しやすくするために，
                かつ既にErlangで書かれているプログラムを段階的にSesterlに移植していけるように，わかりやすいFFIを実現したい．

              * Erlangらしいアーキテクチャをそのまま書けるようにしたい．
                特にOTPライブラリはそれ自体には手を加えずにSesterl側から実装をできるだけ自然な形で利用できるようにしたい．

              * 函数の引数がやたらと増えても，どの引数がどうやって与えられるのかをなるべく捉えやすいようにしたい．

              * `spawn`，`!`，`receive` などの低級な通信もできるだけErlangの意味論に近い形で実現したい．

              * 例外はひとまずキャッチしないことを前提にしたい．

              * ビヘイビアなどによって依存関係が逆転することもあるので，
                Erlang側からもSesterlで実装された函数を簡単に呼べるようにしたい．

              * むやみに通信を起こすプログラムができあがってしまうスパゲティ化を防ぐために，
                純粋な計算と並行処理が発生する計算とを型の水準で区別できるようにしたい．
                また，可能なら “送受信の振舞い” も型の水準で表現できるようにしたい．
            }%
          }
          +p{
            こうした目的設定をうけて，要件を以下のようにすることとしました：

            \listing{
              * 基本的にはML風の言語設計とする．

              * FFIでの函数定義や使用のわかりやすさのため，ML系言語やHaskellのような部分適用は導入せず，
                函数はアリティをもつことにする．

              * 函数の引数の形式としては通常の引数のほかにラベルつき必須引数とラベルつきオプション引数を用意する．

              * OTPライブラリを型の水準で自然に定式化するために，ファンクタをもつモジュールシステムを導入する．

              * 通信が発生する計算はモナドでくるむようにし，
                各並行処理ないしプロセスは “自分がどんな型のメッセージを受け取れるか” の情報をトラックする．
                これを用いて `spawn`，`!`，`receive` 相当の言語機能に型をつける．
                可能なら\dfn{session type} \cite[`Honda1993`];や
                \dfn{multiparty session type} \cite[`HondaYoshidaCarbone2008`];を備えつける．
            }%
          }
        >
        +subsection{他のAltErlang言語}<
          +p{
            やはり人間皆似たことを考えるのか，
            同様の動機でErlangに型をつけようとして創られた言語はSesterl以外にもいくつかあります：

            \listing{
            * \dfn{Alpaca} \cite[`Alpaca`];
              ** OCamlやElmに近い構文と意味論をもち，
                 各プロセスがどんな型のメッセージを受け取れるかの情報を静的に検査することができます．
            * \dfn{Gleam} \cite[`Gleam`];
              ** Rust風の構文と意味論をもつAltErlangです．函数はアリティをもち，ラベルつき引数などの機能ももっています．
                 メッセージにはコア言語では型をつけない方針で，ライブラリの水準で型つけを実現する方針のようです．
                 2021年11月現在非常に精力的に開発されており，つい最近JavaScriptバックエンドも実装されたようです．
            * \dfn{Caramel} \cite[`Caramel`];
              ** OCaml互換の構文で開発されているものです．
                 PIDはメッセージの型をパラメータにとりますが，モナドによる純粋・並行の区別はないようです．
            * \dfn{Hamler} \cite[`Hamler`];
              ** Haskell風の構文と意味論をもつAltErlangです．型クラスを備えていたりします．
                 並行処理に関するモナドがありますが，メッセージの型をパラメータにとるわけではないようです．
                 また，OTPライブラリのビヘイビアは型クラスで定式化されているようです．
            }%
          }
          +p{
            Sesterlの開発を構想した当時，Alpacaと（当時の）Gleamがどんな言語であるか試したのですが，
            当時の自分は特にコア言語の水準でメッセージに型をつけて将来的にsession typeを入れることを重視していたので，
            これらとは別に新たに開発を開始することとしました．
          }
          +p{
            1年半ほど開発して，メッセージに対する型つけも簡潔かつ或る程度便利なものになりましたが，
            session typeは結局それほど強い必要性を感じることがなかったため今に至るまで入っておらず，
            結果的には（後で触れますが）OTPライブラリを型つけするためのF-ing Modulesに基づくモジュールシステムが
            とりわけ顕著な独自性となりました．
          }
        >
      >
      +section{Sesterlの言語設計}<
        +subsection{基礎的な言語機能}<
          +subsubsection{基本的な構文}<
            +p{
              まず基本的な構文は以下のような例でわかると思います：

              \d-code(```
                module Calc :> sig
                  val fact : fun(int) -> int
                  val sum : fun(list<int>) -> int
                  val swap<$a, $b> : fun({$a, $b}) -> {$b, $a}
                  val have_same_length<$a, $b> : fun(list<$a>, list<$b>) -> bool
                end = struct
                  open Stdlib

                  val fact(n) =
                    let rec aux(acc, n) =
                      if n <= 0 then acc else aux(n * acc, n - 1)
                    in
                    aux(1, n)

                  val sum(ns) = List.foldl(fun(acc, n) -> acc + n end, 0, ns)

                  val swap({x, y}) = {y, x}

                  val rec have_same_length<$a, $b>(xs : list<$a>, ys : list<$b>) : bool =
                    case {xs, ys} of
                    | {[], []}                 -> true
                    | {_ :: xtail, _ :: ytail} -> have_same_length(xtail, ytail)
                    | _                        -> false
                    end
                end
              ```);%
              \d-code(```
                require Calc

                module SomeModule = struct
                  val main() = Calc.sum([3, 1, 4, 1, 5, 9, 2])
                end
              ```);

              構文はおおよそML系のものを蹈襲していますが，以下のような特徴があります：

              \listing?:(true){
                * ソースコードのファイルは1つのモジュールの束縛
                  `module` ${X} `= struct` ${\ldots} `end`
                  であり，シグネチャが必要ならモジュール名の直後に
                  `:> sig` ${\ldots} `end`
                  と追記することができる．

                * ファイルの先頭に
                  \no-break-latin{`require` ${X}}
                  と書くことで同一パッケージ中の別ファイルであるモジュール ${X} を読み込める．
                  依存する別パッケージが提供するモジュールは，設定ファイルに記載しておくと
                  どこでも使えるようになる．
                  例えば上記の例では `Stdlib` が別のパッケージに由来するモジュールで，
                  `open Stdlib` で中身が取り出されているので少しわかりにくいが，
                  `Stdlib.List.foldl` が使われている．

                * ストラクチャのメンバとなる（つまり `struct` ${\ldots} `end` 直下の）大域的な束縛は
                  `val` で始め，函数内の局所的な束縛は `let` で行なう．
                  後者は函数のほかに
                  \no-break-latin{`let n = 42 in` ${\ldots}}
                  のように函数でない値も当然束縛できるし，またパターンも
                  \no-break-latin{`let {x, _} = pair in` ${\ldots}}
                  のように使えるが，前者は函数しか束縛できない\footnote{
                    これは後述しますがErlangのモジュール中では函数しか定義できないことに由来します．
                  }．（相互）再帰函数を定義したい場合は
                  `val rec` \no-break-latin{${f_1}`(`${\ldots}`) =` ${e_1}}
                  `and` ${\ldots}
                  `and` \no-break-latin{${f_n}`(`${\ldots}`) =` ${e_n}}
                  のように記述する．`let` の場合も同様．

                * 前述の通り函数はCurry化されないため，函数の型は
                  （一般的な \no-break-latin{${\tau'} `->` ${\tau}} などではなく）
                  \no-break-latin{`fun(`${\tau_1}`,` ${\ldots}`,` ${\tau_n}`) ->` ${\tau}}
                  の形式であり，例えば
                  \no-break-latin{`fun(`${\tau_1}`,` ${\tau_2}`) ->` ${\tau}}
                  は
                  \no-break-latin{`fun(`${\tau_1}`) -> fun(`${\tau_2}`) ->` ${\tau}}
                  とは異なる型である．適用も例えば
                  `List.foldl f i xs`
                  ではなく
                  `List.foldl(f, i, xs)`
                  などと書く．やはり
                  ${e}`(`${e_1}`,` ${e_2}`)`
                  と
                  ${e}`(`${e_1}`)(` ${e_2}`)`
                  とは（具象構文としてだけでなく）抽象構文として異なる．

                * 具象構文上型コンストラクタは前置で，例えば（`int list` ではなく）`list<int>` と記述する．
                  複数の型引数がある場合は `result<int, error>` のようにコンマ区切り．
                  高階の型コンストラクタはサポートしていない．

                * 型註釈を書かずともlet多相での主要型を推論してくれる．
                  再帰函数については，型註釈を全ての引数と戻り値について書いていれば多相再帰も受理する．

                * 直積型は
                  \no-break-latin{`{`${\tau_1}`,` ${\ldots}`,` ${\tau_n}`}`}
                  の形で書き，組（タプル）はErlangと同様に
                  \no-break-latin{`{`${e_1}`,` ${\ldots}`,` ${e_n}`}`}
                  の形で書く．
                  1要素だけの直積型 `{`${\tau}`}` と組 `{`${e}`}` もいくつかの用途のために用意されている．

                * リストの式は
                  \no-break-latin{`[`${e_1}`,` ${\ldots}`,` ${e_n}`]`}
                  とコンマ区切りで書くほか，通常のいわゆるコンスセルの書き方
                  \no-break-latin{${e_1} `::` ${e_2} `::` ${\ldots} `::` ${e_n} `:: []`}
                  も可能．パターンでも同様．

                * 函数定義や函数抽象の引数で（単一の変数に限らず）パターンを使うことができる．

                * 型変数は `$a` のようにドル記号が接頭辞としてつく．
                  全称量化は `<$a, $b>` のようにコンマ区切りで型変数を並べて `<` と `>` で括り，
                  束縛される函数名の直後に書く．シグネチャ中の宣言だけでなく，
                  \no-break-latin{`val have_same_length<$a, $b>(`${\ldots}`) =` ${\ldots}}
                  のように実装中の型註釈でもそのように書くことができる．
              }%
            }
          >
          +subsubsection{代数的データ型とモジュールによる抽象化}<
            +p{
              これも以下の例でほぼ伝わるかと思います：

              \d-code(```
                module BinTree :> sig
                  type t :: (o) -> o
                  val leaf<$a> : fun($a) -> t<$a>
                  val node<$a> : fun($a, t<$a>, t<$a>) -> t<$a>
                  val size<$a> : fun(t<$a>) -> int
                end = struct
                  type t<$a> =
                    | Empty
                    | Node($a, t<$a>, t<$a>)

                  val leaf(x) =
                    Node(x, Empty, Empty)

                  val node(x, tree1, tree2) =
                    Node(x, tree1, tree2)

                  val rec size(tree) =
                    case tree of
                    | Empty                 -> 0
                    | Node(_, tree1, tree2) -> 1 + size(tree1) + size(tree2)
                    end
                end
              ```);%

              `type t :: (o) -> o` が抽象化された型コンストラクタの宣言で，`(o) -> o` は
              1個の型引数をとることを表す種（カインド）です．2個の場合は `(o, o) -> o` という具合にコンマ区切りで増えます．
              高階の種はサポートしていません．
            }
          >
          +subsubsection{列多相によるレコード}<
            +p{
              レコードとは “ラベルつきの組” であり，Sesterlでは
              \no-break-latin{`{`${l_1} `=` ${e_1}`,` ${\ldots}`,` ${l_n} `=` ${e_n}`}`}
              の形で構築でき，
              \no-break-latin{${e}`.`${l}}
              で射影して成分を取り出せます．また，レコード ${e} に対して一部のラベルの値だけを上書きしたレコードも
              \no-break-latin{`{`${e} `with` ${l_1} `=` ${e_1}`,` ${\ldots}`,` ${l_n} `=` ${e_n}`}`}
              で構築できます．
            }
            +p{
              レコードで非自明なのは，射影や更新にどんな型をつけるかです．
              例えば以下の `get_foo` にはどんな型がつくべきでしょうか？

              \d-code(```
                val get_foo(r) = r.foo
              ```);%

              例えばOCamlの場合だと，ラベルは各々1つのレコード型に属するものとして扱われるため，
              `get_foo` に相当する函数は `foo` というラベルをもつと定義された
              唯ひとつのレコード型のみに対して定義された函数として単相になります．
              一方，ラベルが特定の型に紐づくものとは扱われない言語設計も当然ありえて，
              上記のような函数に “`foo` というラベルをもつレコードはなんでも受け取れて，その `foo` の型を戻り値の型とする”
              ということを表す多相な型をつけたりすることも十分考えられます．
              問題はその多相性をどう定式化するかで，既存の体系だと特に2つの方法がよく知られています：

              \listing{
                * \dfn{SML\#}方式のレコード多相 \cite[`Ohori1995`];：
                  \ 式・型・種の3段階からなる2階の型システムで，
                  例えば `get_foo` 相当の函数には
                  ${
                    \forall \alpha \mathrel{::} \mathrm{U}.
                    \ \forall \beta \mathrel{::} \{\{\text!{`foo`} : \alpha\}\}.
                    \ \beta \to \alpha
                  }
                  という具合の型がつきます．ここで ${\mathrm{U}} は任意の型につく種，
                  ${\{\{\text!{`foo`} : \alpha\}\}} は
                  “`foo` というラベルをもち，それに対応する型が ${\alpha} であるようなレコード型” 全体につく種です．
                  この型システムの特徴は，レコードに対して多相に型つけできるだけでなく，
                  拡張や結合など一部のレコードに対する操作ができないという制約を設けつつも
                  実行時のオーバーヘッドを減らせるような定式化になっていることです．

                * \dfn{列多相} \cite[`GasterJones1996`];：
                  \ いろいろな変種がありますが，概して\dfn{列} (row) という構文的対象が型とは別にあるのが特徴です．
                  列とは大雑把に言えば “レコードのラベルと型の組み合わせの一部だけ切り出したもの” で，
                  例えば `{foo : int, bar : bool, baz : string}` の “`bar : bool, baz : string` の部分”
                  といったものが列に該当します．
                  2階の型システムとして列多相を定式化すると，
                  `get_foo` 相当の函数には
                  ${
                    \forall \alpha \mathrel{::} \mathrm{Type}.
                    \ \forall \rho \mathrel{::} \mathop{\mathrm{Row}}\{\text!{`foo`}\}.
                    \ \mathop{\mathrm{record}}\{\text!{`foo`} : \alpha \| \rho\} \to \alpha
                  }
                  などという型がつく具合になります．
                  ここで ${\alpha} は通常の型変数で，${\mathrm{Type}} という種がつきますが，
                  ${\rho} は\dfn{列変数}と呼ばれ，列が全称量化されたものです．
                  列 ${r} に対して ${\mathop{\mathrm{record}}r} が “${r} を内容としてもつレコード型” であり，
                  ${\{l : \tau \| r\}} とは “${l : \tau} を列 ${r} の先頭につけ足してできる列” です．
                  レコードに含まれるものとして意味を為すために1つの列に於いては各ラベルは高々1回までしか出現してはいけないため，
                  ${\{l : \tau \| r\}} に於いて ${r} はラベル ${l} を含んでいてはならず，したがってここでの
                  ${\{\text!{foo} : \alpha \| \rho\}} が意味を為すためには
                  列変数 ${\rho} は ${\text!{foo}} を含む列にinstantiateされてはいけないことになります．
                  こうした制約を表現するために列の種は ${\mathop{\mathrm{Row}}L} とラベルの集合 ${L} を伴っており，
                  ここでは ${L} に相当するのが ${\{\text!{foo}\}} という1元集合というわけです．
              }%
            }
            +p{
              Sesterlではv0.1.xの頃にはSML\#のレコード多相を導入していました\footnote{
                これは何か列多相と比較の上決めたわけではなく，
                単に開発開始当時に筆者がSML\#のレコード多相くらいしかレコードを多相的に扱う手法の直観を
                獲得していなかったことに起因します．
              }が，次第に以下のような点が気になってきました：

              \listing{
                * レコードに関してパフォーマンスがクリティカルに必要なわけではないので，
                  実行時のオーバーヘッドを減らすようなコンパイル処理を実装するためにこの型システムを活かしたりはしていないし，
                  それならばレコードに対する操作を制約している意味があまりない．

                * 種が型に構文的に依存するため，以下のようなことが問題になる：

                  ** 通常のlet多相と違って型変数の全称量化の順序に意味があるなど
                     そもそも型システムとして幾分か複雑なため，型推論上の型と種の扱い方も複雑になりやすい．
                     量化の順番に意味があるというのは，例えば上記の `get_foo` の型つけの場合に
                     ${
                       \forall \beta \mathrel{::} \{\{\text!{`foo`} : \alpha\}\}.
                       \forall \alpha \mathrel{::} \mathrm{U}.
                       \ \beta \to \alpha
                     }
                     と量化の順序を入れ替えると意味を為さない別の型になってしまうことなど．

                  ** 他の型システムの拡張や型推論処理を内部的に効率化したアルゴリズムなどと
                     このレコードに関する推論が適切に両立できるかが非自明．
              }%
            }
            +p{
              そこでこれを緩和する方法としてSesterl v0.2.0からはレコード型の定式化を列多相に切り替えることにしました．
              上記の `get_foo` に対しては以下のように型がつきます：

              \d-code(```
                val get_foo<$a, ?$r :: (foo)> : fun({foo : $a | ?$r}) -> $a
              ```);%

              列変数は `?$` という接頭辞をもつことにし，列変数に対する種は `(`${L}`)` の形で
              記述することにしました（複数のラベルからなる集合の場合はコンマ区切りで書きます）．
              また，単に `{foo : $a | ?$r}` と書いただけでレコード型として扱い，
              列自体を書く方法は（今のところ必要に感じていないため）ひとまず提供しないことにしました．
            }
            +p{
              列多相に切り替えた際，型推論アルゴリズムの実装をかなり簡略化できたほか，
              既存のレコード多相に準拠して既に書いていたプログラムは型註釈を除いて書き換える必要なく移行でき，
              とても使い勝手が良くなりました．
              というわけで現在のSesterlでは列多相に基づいたレコードの型つけが採用されています．
            }
          >
          +subsubsection{ラベルつき引数}<
            +p{
              さて，引数が多くなっても何の引数なのかわかりやすくするために，かつ典型的な値が決まっている引数は適宜省略できるように，
              ラベルつき引数を導入したいのでした．
              まず，ラベルつき必須引数は “単にラベルを辞書順で並べて通常の引数に帰着する” という具合の方法で比較的簡単に実現できます．
              というわけで以下のように `-foo` というラベルによって必須引数を書けるようにしました：

              \d-code(```
                val rec foldl(-f f, -init init, -list xs) =
                  case xs of
                  | []      -> init
                  | y :: ys -> foldl(-init f(init, y), -list ys, -f f)
                  end
              ```);%

              再帰の適用で引数の順序が定義の際の引数の順序と違っていますがこれでも問題なく通るという算段です．
              この `foldl` には以下のように型がつきます：

              \d-code(```
                val foldl<$a, $b> : fun(-f fun($a, $b) -> $a, -init $a, -list list<$b>) -> $a
              ```);%

              というわけでラベルつき必須引数のサポートは簡単です．
            }
            +p{
              一方でラベルつきオプション引数は結構非自明な点があります．
              とりあえず，必須引数では `-foo` だったラベルの形式をオプション引数では `?foo` にして，
              適用時に省略されたら `None` が渡されたことに，
              `?foo` ${v} のように値が与えられていたら `Some(`${v}`)` が渡されたことにすることを考えましょう．
              ラベルつきオプション引数をもつ函数を定義する側はこれだけでOKです．例えば以下のように使えます：

              \d-code(```
                val succ(n : int, ?diff diff_opt : option<int>) : int =
                  case diff_opt of
                  | None       -> n + 1
                  | Some(diff) -> n + diff
                  end
              ```);%

              しかし，次のような高階函数にはどんな型をつけるべきでしょうか？

              \d-code(```
                val use_optional(f) = f(42, ?foo 57) + 1
              ```);%

              特にこの函数の引数 `f` にはどんな型がつくべきでしょうか？
              `fun(int, ?foo int) -> int` のような型を想定するかもしれませんが，
              “`?foo` のほかに `?bar` のようなオプション引数も受け取れて，ここでは単に `?foo` しか与えられないだけ”
              という函数も `f` として適格なため，このことを表現する多相な型をつけたくなります．
            }
            +p{
              実は，前節で触れた列多相をこのようなオプション引数の型つけに転用することができます．
              これは同様の仕組みを取っている論文や実装を見たことはなく，筆者が考案したつもりのものですが，
              仕組みとしてはシンプルであって比較的すぐ思いつくようなものなのでここで紹介します\footnote{
                多分大丈夫だろうとは信じていますが，
                この手法の正当性（保存や進行といった型安全性）を証明したというわけではないです．
                論文にしたためるほどの内容とは思いませんが，餘裕があるときに証明してみたいことではあります．
              }．
            }
            +p{
              直観としては1つの函数のとるオプション引数全体を列だとみなすという方法です．
              すなわち，（簡単のためラベルつき必須引数は通常の引数と同一視して扱うこととして）函数の型は
              \no-break-latin{`fun(`${\tau_1}`,` ${\ldots}`,` ${\tau_n}`,` ${r}`) ->` ${\tau}}
              という具合に列 ${r} を1つオプション引数用にもっていると考えます．
              すると，上記の `use_optional` は
              \no-break-latin{%
                ${\forall\rho \mathrel{::} \mathop{\mathrm{Row}}\{\text!{`foo`}\}.}
                `fun(fun(int,` ${\{\text!{`foo`} : \text!{`int`} \| \rho\}}`) -> int) -> int`}
              という型をつければよさそうだ，という気がしてきます．
              こうして餘分なオプション引数をもつ函数でも列変数で吸収して扱えるようになります．
              Sesterlの具象構文としては以下のように記述することにしました：

              \d-code(```
                val use_optional<?$r :: (foo)> : fun(fun(int, ?foo int, ?$r) -> int) -> int
              ```);%
            }
          >
          +subsubsection{FFI}<
            +p{
              FFIは特にErlang製の既存実装を再利用しやすくしたり
              Erlang製の実装からSesterl製の実装への段階的な移行を容易にしたりするために
              是非とも素直なものにしたい機能でした．
              以下のような簡単な記述でFFIが実現できます：

              \d-code(````
                val binary_to_chars : fun(binary) -> list<char> = external 1 ```
                  binary_to_chars(Bin) ->
                      erlang:binary_to_list(Bin).
                ```
              ````);%

              すなわち，文字列リテラルでErlangの函数定義が直接書け，それに型をつけてSesterl側から使うことができます．
              `external` の直後にはアリティを指定します\footnote{
                このアリティはコンパイラが `-export` の内容を出力するのに必要です．
                文字列リテラル内のErlangのコードを構文解析するようにすればアリティを書く必要はないのですが，
                現状ではErlangコードは構文解析せず出力するErlangソースコードにそのまま貼りつける仕組みになっています．
              }．Sesterlの値とErlangの値との紐づけは以下のようになっています：

              \listing{
                * 整数，浮動小数点数，バイナリ，PID，リスト，タプルなどの値はそのまま自然な形でErlangの値になっている．

                * レコードは，ラベルをアトムのキーとするマップで表現される．

                * 代数的データ型の値は，引数を取らないコンストラクタ ${C} は小文字始まりのアトム ${c} で，
                  引数を取るコンストラクタ
                  \no-break-latin{${C}`(`${v_1}`,` ${\ldots}`,` ${v_n}`)`}
                  はアトムを先頭とするタプル
                  \no-break-latin{`{`${c}`,` ${v_1}`,` ${\ldots}`,` ${v_n}`}`}
                  で表現される．
                  ${C} と ${c} の対応は例えばアッパーキャメルケースの `SomeConstructor` が
                  スネークケースの `some_constructor` に変換される要領．
                  ただし，`option` 型の `Some` と `None` は利便性のため例外的に
                  それぞれ `ok` と `error` で表現される\footnote{
                    ユーザ定義の代数的データ型でも，本来の規則とは違うアトムにコンパイルしたい場合は
                    そのように指定する註釈がつけられるようにしています．
                  }．

                * 函数定義および函数抽象では，通常の引数とラベルつき必須引数は
                  Erlangの普通の引数として扱われ，ラベルつき必須引数はラベルの辞書順で並ぶ．
                  オプション引数は最後の1引数として単一のマップになっており，
                  オプション引数をひとつも与えない場合はその最後の1引数が缺ける．
                  そのため，FFIの函数でオプション引数を受け取るものにしたい場合は
                  Sesterl側では1つの函数であっても
                  Erlang側ではオプション引数のマップを受け取るものと受け取らないものの2種を与える必要がある．
              }%
            }
          >
          +subsubsection{並行処理}<
            +p{\REMAINS{並行処理}}
          >
        >
        +subsection{SesterlをOTP Design Principlesに適合させるために必要だった言語機能たち}<
          +p{\REMAINS{ファンクタ，static interpretation，future workとして再帰モジュール}}
        >
      >
      +section{天九のルール}<
        +p{\REMAINS{天九のルールを簡単に紹介}}
      >
      +section{ゲームサーバとクライアントの設計}<
        +p{\REMAINS{設計の話．これは直接Erlang/OTPで実装する場合でも全く同じ}}
      >
      +section{まとめ}<
        +p{\REMAINS{まとめ}}
      >
    >
  >

end
