#+TITLE: Verilogで実行時検証と形式検証をした話
#+AUTHOR: MasWag

* COMMENT Materials

** https://symbiyosys.readthedocs.io/en/latest/

* はじめに

** 諸般の事情でHDLについて調べていたらSymbiYosysというツールを見つけた

** 筆者はこれまで、遠い昔にVHDLを書いた以外にHDLに関する経験はないがやってみた

* How to install

** 依存関係がありすぎて大変そう

** ひとまずdocker imageを使ってみる

*** https://hub.docker.com/r/andrsmllr/symbiyosys

* Half Adder

#+BEGIN_SRC verilog :tangle half_adder.v :noweb yes
  module half_adder (input A, input B, output wire carry, output wire sum);
   <<VERILOG_HALF_ADDER_BODY>>
  endmodule
#+END_SRC

#+NAME: VERILOG_HALF_ADDER_BODY
#+BEGIN_SRC verilog
  assign carry = A & B;
  assign sum = A ^ B;
#+END_SRC

** COMMENT Trial with Verilator

*** Verilator

**** How to install

#+BEGIN_SRC sh
brew install verilator
#+END_SRC

**** How to use Verilator

***** https://msyksphinz.hatenablog.com/entry/2020/05/06/040000

#+BEGIN_SRC sh
verilator --version
#+END_SRC

#+RESULTS:
: Verilator 4.108 2021-01-10 rev v4.106-158-g484b76e5b

#+BEGIN_SRC sh
verilator -cc half_adder.v
#+END_SRC

#+RESULTS:


*** Manual test with an exhaustive test bench

**** Write the test bench in C++

#+BEGIN_SRC c++ :tangle half_adder_bench.cc
  #include <cstdio>
  #include <verilated.h>
  #include <tuple>
  #include <array>
  #include "./Vhalf_adder.h"

  int main(int argc, char *argv[])
  {
    Verilated::commandArgs(argc, argv);

    // Instanciate DUT
    Vhalf_adder *dut = new Vhalf_adder();

    // Give the initial inputs
    dut->clk = 0;
    dut->A = 0;
    dut->B = 0;

    // define the constants
    const int clock_interval = 10;
    const int simulation_duration = 100;

    // construct the table of inputs
    std::array<std::tuple<bool, bool>, 4> input = {{
        {0, 0},
        {1, 0},
        {0, 1},
        {1, 1}
      }};
    int  input_index = 0;

    for (int i = 0; i < simulation_duration; ++i) {
      if ((i % (clock_interval / 2)) == 0) {
        // Toggle clock 
        dut->clk = !(dut->clk);
      }

      if ((i % clock_interval) == 0) {
        // update the input
        std::tie(dut->A, dut->B) = input[input_index++];
        input_index %= input.size();
      }

      // evaluate DUT
      dut->eval();

      if ((i % clock_interval) == 0) {
        // print the I/O
        printf ("A: %d, B: %d, carry: %d, sum: %d\n", dut->A, dut->B, dut->carry, dut->sum);
      }
    }

    return 0;
  }
#+END_SRC

**** Execute the test bench

***** Build

#+BEGIN_SRC sh :results org
  verilator -cc half_adder.v -exe half_adder_bench.cc
  make -C obj_dir -f Vhalf_adder.mk
#+END_SRC

#+RESULTS:
#+begin_src org
clang++  -I.  -MMD -I/usr/local/Cellar/verilator/4.108/share/verilator/include -I/usr/local/Cellar/verilator/4.108/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -faligned-new -fbracket-depth=4096 -fcf-protection=none -Qunused-arguments -Wno-bool-operation -Wno-tautological-bitwise-compare -Wno-parentheses-equality -Wno-sign-compare -Wno-uninitialized -Wno-unused-parameter -Wno-unused-variable -Wno-shadow      -std=gnu++14 -Os -c -o half_adder_bench.o ../half_adder_bench.cc
/usr/bin/perl /usr/local/Cellar/verilator/4.108/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vhalf_adder.cpp Vhalf_adder__Slow.cpp Vhalf_adder__Syms.cpp > Vhalf_adder__ALL.cpp
clang++  -I.  -MMD -I/usr/local/Cellar/verilator/4.108/share/verilator/include -I/usr/local/Cellar/verilator/4.108/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -faligned-new -fbracket-depth=4096 -fcf-protection=none -Qunused-arguments -Wno-bool-operation -Wno-tautological-bitwise-compare -Wno-parentheses-equality -Wno-sign-compare -Wno-uninitialized -Wno-unused-parameter -Wno-unused-variable -Wno-shadow      -std=gnu++14 -Os -c -o Vhalf_adder__ALL.o Vhalf_adder__ALL.cpp
Archive ar -cr Vhalf_adder__ALL.a Vhalf_adder__ALL.o
clang++    half_adder_bench.o verilated.o Vhalf_adder__ALL.a      -o Vhalf_adder
#+end_src

***** Execute

#+BEGIN_SRC sh :results org
  ./obj_dir/Vhalf_adder
#+END_SRC

#+RESULTS:
#+begin_src org
A: 0, B: 0, carry: 0, sum: 0
A: 1, B: 0, carry: 0, sum: 1
A: 0, B: 1, carry: 0, sum: 1
A: 1, B: 1, carry: 1, sum: 0
A: 0, B: 0, carry: 0, sum: 0
A: 1, B: 0, carry: 0, sum: 1
A: 0, B: 1, carry: 0, sum: 1
A: 1, B: 1, carry: 1, sum: 0
A: 0, B: 0, carry: 0, sum: 0
A: 1, B: 0, carry: 0, sum: 1
#+end_src


*** Assertion with an exhaustive testbench

**** Half adder with assertion

#+BEGIN_SRC verilog
   always @(posedge clk) assert ({carry, sum} == A + B);
#+END_SRC

#+BEGIN_SRC verilog :tangle half_adder_with_assertion.v :noweb yes
  module clocked_half_adder (input clk, input A, input B, output reg carry, output reg sum);
   <<VERILOG_HALF_ADDER_BODY>>
   <<VERILOG_HALF_ADDER_ASSERTION>>
  endmodule
#+END_SRC

**** Test bench

#+BEGIN_SRC c++ :tangle half_adder_with_assertion_bench.cc
  #include <cstdio>
  #include <verilated.h>
  #include <tuple>
  #include <array>
  #include "./Vhalf_adder_with_assertion.h"

  int main(int argc, char *argv[])
  {
    Verilated::commandArgs(argc, argv);

    // Instanciate DUT
    Vhalf_adder_with_assertion *dut = new Vhalf_adder_with_assertion();

    // Give the initial inputs
    dut->clk = 0;
    dut->A = 0;
    dut->B = 0;

    // define the constants
    const int clock_interval = 10;
    const int simulation_duration = 100;

    // construct the table of inputs
    std::array<std::tuple<bool, bool>, 4> input = {{
        {0, 0},
        {1, 0},
        {0, 1},
        {1, 1}
      }};
    int  input_index = 0;

    for (int i = 0; i < simulation_duration; ++i) {
      if ((i % (clock_interval / 2)) == 0) {
        // Toggle clock 
        dut->clk = !(dut->clk);
      }

      if ((i % clock_interval) == 0) {
        // update the input
        std::tie(dut->A, dut->B) = input[input_index++];
        input_index %= input.size();
      }

      // evaluate DUT
      dut->eval();

      if ((i % clock_interval) == 0) {
        // print the I/O
        printf ("A: %d, B: %d, carry: %d, sum: %d\n", dut->A, dut->B, dut->carry, dut->sum);
      }
    }

    return 0;
  }
#+END_SRC

**** Execute the test bench

***** Build

#+BEGIN_SRC sh :results org
  verilator -cc half_adder_with_assertion.v -exe half_adder_with_assertion_bench.cc
  make -C obj_dir -f Vhalf_adder_with_assertion.mk
#+END_SRC

#+RESULTS:
#+begin_src org
clang++  -I.  -MMD -I/usr/local/Cellar/verilator/4.108/share/verilator/include -I/usr/local/Cellar/verilator/4.108/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -faligned-new -fbracket-depth=4096 -fcf-protection=none -Qunused-arguments -Wno-bool-operation -Wno-tautological-bitwise-compare -Wno-parentheses-equality -Wno-sign-compare -Wno-uninitialized -Wno-unused-parameter -Wno-unused-variable -Wno-shadow      -std=gnu++14 -Os -c -o half_adder_with_assertion_bench.o ../half_adder_with_assertion_bench.cc
/usr/bin/perl /usr/local/Cellar/verilator/4.108/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vhalf_adder_with_assertion.cpp Vhalf_adder_with_assertion__Slow.cpp Vhalf_adder_with_assertion__Syms.cpp > Vhalf_adder_with_assertion__ALL.cpp
clang++  -I.  -MMD -I/usr/local/Cellar/verilator/4.108/share/verilator/include -I/usr/local/Cellar/verilator/4.108/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -faligned-new -fbracket-depth=4096 -fcf-protection=none -Qunused-arguments -Wno-bool-operation -Wno-tautological-bitwise-compare -Wno-parentheses-equality -Wno-sign-compare -Wno-uninitialized -Wno-unused-parameter -Wno-unused-variable -Wno-shadow      -std=gnu++14 -Os -c -o Vhalf_adder_with_assertion__ALL.o Vhalf_adder_with_assertion__ALL.cpp
Archive ar -cr Vhalf_adder_with_assertion__ALL.a Vhalf_adder_with_assertion__ALL.o
clang++    half_adder_with_assertion_bench.o verilated.o Vhalf_adder_with_assertion__ALL.a      -o Vhalf_adder_with_assertion
#+end_src

***** Execute

#+BEGIN_SRC sh :results org
  ./obj_dir/Vhalf_adder_with_assertion
#+END_SRC

#+RESULTS:
#+begin_src org
A: 0, B: 0, carry: 0, sum: 0
A: 1, B: 0, carry: 0, sum: 1
A: 0, B: 1, carry: 0, sum: 1
A: 1, B: 1, carry: 1, sum: 0
A: 0, B: 0, carry: 0, sum: 0
A: 1, B: 0, carry: 0, sum: 1
A: 0, B: 1, carry: 0, sum: 1
A: 1, B: 1, carry: 1, sum: 0
A: 0, B: 0, carry: 0, sum: 0
A: 1, B: 0, carry: 0, sum: 1
#+end_src

***** Issue: Verilator does not support system verilog assertion :-(

****** Icarus Verilog supports is :-) https://github.com/steveicarus/iverilog/issues/193

**** Wrong half adder

#+BEGIN_SRC verilog :tangle wrong_half_adder_with_assertion.v :noweb yes
  module clocked_wrong_half_adder_with_assertion (input clk, input A, input B, output carry, output sum);
   <<VERILOG_WRONG_CLOCKED_HALF_ADDER_BODY>>
   <<VERILOG_HALF_ADDER_ASSERTION>>
  endmodule
#+END_SRC

***** COMMENT

#+NAME: VERILOG_WRONG_CLOCKED_HALF_ADDER_BODY
#+BEGIN_SRC verilog
     initial carry = 0;
     initial sum = 0;
   
     always @(posedge clk) begin
        carry <= A & B;
        sum <= A | B;
     end
#+END_SRC

**** Test bench

#+BEGIN_SRC c++ :tangle wrong_half_adder_with_assertion_bench.cc
  #include <cstdio>
  #include <verilated.h>
  #include <tuple>
  #include <array>
  #include "./Vwrong_half_adder_with_assertion.h"

  int main(int argc, char *argv[])
  {
    Verilated::commandArgs(argc, argv);

    // Instanciate DUT
    Vwrong_half_adder_with_assertion *dut = new Vwrong_half_adder_with_assertion();

    // Give the initial inputs
    dut->clk = 0;
    dut->A = 0;
    dut->B = 0;

    // define the constants
    const int clock_interval = 10;
    const int simulation_duration = 100;

    // construct the table of inputs
    std::array<std::tuple<bool, bool>, 4> input = {{
        {0, 0},
        {1, 0},
        {0, 1},
        {1, 1}
      }};
    int  input_index = 0;

    for (int i = 0; i < simulation_duration; ++i) {
      if ((i % (clock_interval / 2)) == 0) {
        // Toggle clock 
        dut->clk = !(dut->clk);
      }

      if ((i % clock_interval) == 0) {
        // update the input
        std::tie(dut->A, dut->B) = input[input_index++];
        input_index %= input.size();
      }

      // evaluate DUT
      dut->eval();

      if ((i % clock_interval) == 0) {
        // print the I/O
        printf ("A: %d, B: %d, carry: %d, sum: %d\n", dut->A, dut->B, dut->carry, dut->sum);
      }
    }

    return 0;
  }
#+END_SRC

**** Execute the test bench

***** Build

#+BEGIN_SRC sh :results org
  verilator -cc wrong_half_adder_with_assertion.v -exe wrong_half_adder_with_assertion_bench.cc
  make -C obj_dir -f Vwrong_half_adder_with_assertion.mk
#+END_SRC

#+RESULTS:
#+begin_src org
clang++  -I.  -MMD -I/usr/local/Cellar/verilator/4.108/share/verilator/include -I/usr/local/Cellar/verilator/4.108/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -faligned-new -fbracket-depth=4096 -fcf-protection=none -Qunused-arguments -Wno-bool-operation -Wno-tautological-bitwise-compare -Wno-parentheses-equality -Wno-sign-compare -Wno-uninitialized -Wno-unused-parameter -Wno-unused-variable -Wno-shadow      -std=gnu++14 -Os -c -o wrong_half_adder_with_assertion_bench.o ../wrong_half_adder_with_assertion_bench.cc
/usr/bin/perl /usr/local/Cellar/verilator/4.108/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT=include Vwrong_half_adder_with_assertion.cpp Vwrong_half_adder_with_assertion__Slow.cpp Vwrong_half_adder_with_assertion__Syms.cpp > Vwrong_half_adder_with_assertion__ALL.cpp
clang++  -I.  -MMD -I/usr/local/Cellar/verilator/4.108/share/verilator/include -I/usr/local/Cellar/verilator/4.108/share/verilator/include/vltstd -DVM_COVERAGE=0 -DVM_SC=0 -DVM_TRACE=0 -DVM_TRACE_FST=0 -faligned-new -fbracket-depth=4096 -fcf-protection=none -Qunused-arguments -Wno-bool-operation -Wno-tautological-bitwise-compare -Wno-parentheses-equality -Wno-sign-compare -Wno-uninitialized -Wno-unused-parameter -Wno-unused-variable -Wno-shadow      -std=gnu++14 -Os -c -o Vwrong_half_adder_with_assertion__ALL.o Vwrong_half_adder_with_assertion__ALL.cpp
Archive ar -cr Vwrong_half_adder_with_assertion__ALL.a Vwrong_half_adder_with_assertion__ALL.o
clang++    wrong_half_adder_with_assertion_bench.o verilated.o Vwrong_half_adder_with_assertion__ALL.a      -o Vwrong_half_adder_with_assertion
#+end_src

***** Execute

#+BEGIN_SRC sh :results org
  ./obj_dir/Vwrong_half_adder_with_assertion
#+END_SRC

#+RESULTS:
#+begin_src org
A: 0, B: 0, carry: 0, sum: 0
A: 1, B: 0, carry: 0, sum: 0
A: 0, B: 1, carry: 0, sum: 0
A: 1, B: 1, carry: 0, sum: 0
A: 0, B: 0, carry: 0, sum: 0
A: 1, B: 0, carry: 0, sum: 0
A: 0, B: 1, carry: 0, sum: 0
A: 1, B: 1, carry: 0, sum: 0
A: 0, B: 0, carry: 0, sum: 0
A: 1, B: 0, carry: 0, sum: 0
#+end_src


** Testing with Icarus Verilog

*** What is Icarus Verilog

**** Reference: http://cellspe.matrix.jp/zerofpga/icarus.html

**** How to install

#+BEGIN_SRC sh
brew install icarus-verilog
#+END_SRC

**** How to use Icarus Verilog

***** Compile
        
#+BEGIN_SRC sh
iverilog -o [OUTPUT_EXECUTABLE] [INPUT_VERILOG_FILES]
#+END_SRC

***** Simulation

#+BEGIN_SRC sh
vvp [EXECUTABLE]
#+END_SRC

**** Note: Concurrent assertion is not supported by Icarus Verilog

For example, we cannot use the following in Icarus Verilog.

#+BEGIN_SRC verilog
  assert property (@(posedge(clk) {carry, sum} == $past(A) + $past(B)));
#+END_SRC

*** Manual test with an exhaustive test bench

**** Write the test bench in System Verilog

#+BEGIN_SRC verilog :tangle half_adder_bench.v :noweb yes
  `timescale 1ns / 1ps
  module half_adder_bench();
     <<SIMULATOR_PARAMETERS>>
     <<HALF_ADDER_BENCH_SIGNAL_DEFINITION>>
     <<HALF_ADDER_BENCH_SIMULATOR_CONFIGURATION>>
     <<CLOCK_GENERATION>>
     <<HALF_ADDER_BENCH_INPUT_GENERATION>>
     <<HALF_ADDER_INSTANTIATE>>
  endmodule
#+END_SRC

***** Define the constants

#+NAME: SIMULATOR_PARAMETERS
#+BEGIN_SRC verilog
  parameter STEP = 10; // 10nanosec: 100MHz
  parameter TICKS = 20;
#+END_SRC

***** Define the signals

#+NAME: HALF_ADDER_BENCH_SIGNAL_DEFINITION
#+BEGIN_SRC verilog
  reg clk;
  reg A;
  reg B;
  wire carry;
  wire sum;
#+END_SRC

***** Simulator configuration

#+NAME: HALF_ADDER_BENCH_SIMULATOR_CONFIGURATION
#+BEGIN_SRC verilog
  initial begin
   // write the wave to wave.fst
   // Note: FST is better than VCD: https://iverilog.fandom.com/wiki/Vvp_Flags#VCD.2FFST.2FLXT_arguments
    $dumpfile("wave.fst");
    // include all the wave information in half_adder
    $dumpvars(0, half_adder);
  end
#+END_SRC

***** Clock generation

#+NAME: CLOCK_GENERATION
#+BEGIN_SRC verilog
  initial begin
     clk = 1'b1;
     repeat(TICKS * 2) begin
        // reverse the clock
        #(STEP / 2) clk = ~clk;
     end
     $finish;
  end
#+END_SRC

***** Generate input signal

#+NAME: HALF_ADDER_BENCH_INPUT_GENERATION
#+BEGIN_SRC verilog
  reg [1:0] step;
  always begin
     step = 0;
     forever begin
        step = step + 1;
        case (step)
          0: begin
             A <= 1'b0;
             B <= 1'b0;
          end
          1: begin
             A <= 1'b1;
             B <= 1'b0;
          end
          2: begin
             A <= 1'b1;
             B <= 1'b1;
          end
          3: begin
             A <= 1'b0;
             B <= 1'b1;
          end
          default: begin
             A <= 1'b0;
             B <= 1'b0;
          end
        endcase
        #STEP;
     end
  end
#+END_SRC

***** Instantiate

#+NAME: HALF_ADDER_INSTANTIATE
#+BEGIN_SRC verilog
  half_adder half_adder (
              .A(A),
              .B(B),
              .carry(carry),
              .sum(sum)
    );
#+END_SRC

**** Execute the test bench

***** Compile
        
#+BEGIN_SRC sh
iverilog -o half_adder half_adder.v half_adder_bench.v
#+END_SRC

#+RESULTS:

***** Simulation

#+BEGIN_SRC sh
vvp half_adder -fst 
#+END_SRC

#+RESULTS:
: FST info: dumpfile wave.fst opened for output.

**** Observe the output by gtkwave

***** Install gtkwave

#+BEGIN_SRC sh
brew install gtkwave
#+END_SRC

***** open gtkwave and observe the output

Open tab by Application+T

*** Assertion with an exhaustive testbench

**** Half adder with assertion

値代入のタイミングで見ると変更直前の値をテストしているのかそうでないのかがわからないので、値代入と 0.5周期だけずらしたタイミングで値をテストする。

#+NAME: VERILOG_HALF_ADDER_ASSERTION
#+BEGIN_SRC verilog
  always @(negedge clk) begin
   forever begin
      assert ({carry, sum} == A + B);
      #STEP;
    end
  end
#+END_SRC

#+BEGIN_SRC verilog :tangle half_adder_bench_with_assertion.v :noweb yes
  `timescale 1ns / 1ps
  module half_adder_bench();
     <<SIMULATOR_PARAMETERS>>
     <<HALF_ADDER_BENCH_SIGNAL_DEFINITION>>
     <<HALF_ADDER_BENCH_SIMULATOR_CONFIGURATION>>
     <<CLOCK_GENERATION>>
     <<HALF_ADDER_BENCH_INPUT_GENERATION>>
     <<HALF_ADDER_INSTANTIATE>>
     <<VERILOG_HALF_ADDER_ASSERTION>>
  endmodule
#+END_SRC

**** Execute the test bench

***** Compile
        
#+BEGIN_SRC sh
iverilog -g2012 -o half_adder_with_assertion half_adder.v half_adder_bench_with_assertion.v
#+END_SRC

#+RESULTS:

***** Simulation

#+BEGIN_SRC sh :results org
vvp half_adder_with_assertion -fst 
#+END_SRC

#+RESULTS:
#+begin_src org
FST info: dumpfile wave.fst opened for output.
#+end_src

**** Wrong half adder

#+BEGIN_SRC verilog :tangle wrong_half_adder.v :noweb yes
  module half_adder (input A, input B, output wire carry, output wire sum);
     assign carry = A & B;
     assign sum = A | B;
  endmodule
#+END_SRC

**** Execute the test bench for wrong half adder

***** Compile
        
#+BEGIN_SRC sh
iverilog -g2012 -o wrong_half_adder wrong_half_adder.v half_adder_bench_with_assertion.v
#+END_SRC

#+RESULTS:

***** Simulation

#+BEGIN_SRC sh :results org
vvp wrong_half_adder -fst 
#+END_SRC

#+RESULTS:
#+begin_src org
FST info: dumpfile wave.fst opened for output.
ERROR: half_adder_bench_with_assertion.v:63: 
       Time: 15000 Scope: half_adder_bench
ERROR: half_adder_bench_with_assertion.v:63: 
       Time: 55000 Scope: half_adder_bench
ERROR: half_adder_bench_with_assertion.v:63: 
       Time: 95000 Scope: half_adder_bench
ERROR: half_adder_bench_with_assertion.v:63: 
       Time: 135000 Scope: half_adder_bench
ERROR: half_adder_bench_with_assertion.v:63: 
       Time: 175000 Scope: half_adder_bench
#+end_src


** TODO Verification with SymbiYosys

*** Half adder with assertion

#+NAME: VERILOG_HALF_ADDER_ASSERTION_ALWAYS
#+BEGIN_SRC verilog
   always_comb assert ({carry, sum} == A + B);
#+END_SRC

#+BEGIN_SRC verilog :tangle half_adder_with_assertion.v :noweb yes
   module half_adder (input A, input B, output wire carry, output wire sum);
    <<VERILOG_HALF_ADDER_BODY>>
    <<VERILOG_HALF_ADDER_ASSERTION_ALWAYS>>
   endmodule
#+END_SRC

*** Configure SymbiYosys

#+BEGIN_SRC conf :tangle half_adder.sby
[options]
mode prove

[engines]
smtbmc

[script]
read -formal half_adder_with_assertion.v
prep -top half_adder

[files]
half_adder_with_assertion.v
#+END_SRC

*** Verify with SymbiYosys

#+BEGIN_SRC sh
docker run -it -v ${PWD}:/mnt andrsmllr/symbiyosys
cd /mnt
rm -rf /mnt/half_adder
sby /mnt/half_adder.sby
#+END_SRC

*** Wrong half adder with assertion

#+BEGIN_SRC verilog :tangle wrong_half_adder_with_assertion.v :noweb yes
   module half_adder (input A, input B, output wire carry, output wire sum);
      assign carry = A & B;
      assign sum = A | B;
    <<VERILOG_HALF_ADDER_ASSERTION_ALWAYS>>
   endmodule
#+END_SRC

*** Configure SymbiYosys

#+BEGIN_SRC conf :tangle wrong_half_adder.sby
[options]
mode prove

[engines]
smtbmc

[script]
read -formal wrong_half_adder_with_assertion.v
prep -top half_adder

[files]
wrong_half_adder_with_assertion.v
#+END_SRC

*** Verify with SymbiYosys

#+BEGIN_SRC sh
docker run -it -v ${PWD}:/mnt andrsmllr/symbiyosys
cd /mnt
rm -rf /mnt/wrong_half_adder
sby /mnt/wrong_half_adder.sby
#+END_SRC

* Full Adder

* 8bit adder

* fadd

