@require: itemize
@require: code
@require: base/image
@require: pervasives

@require: class-yabaitech/yabaitech
@require: ruby/ruby

@import: local
% @import: bib

module MasWag : sig

  val article : block-text

end = struct

let article = '<
    +chapter ?:(`maswag-article`)
    (|
        bibliography = []; %maswag-bibliography;
        title = {チルノのパーフェクトフォワーディング (完全転送) 教室};
        author = {MasWag};
        title-for-toc = Option.none;
        subtitle = Option.none;
    |)
    <
    +section ?:(`はじめに`) {はじめに} <
    +quote<
    +p {
      みんなぁ～！　
    }
    +p {
      C++11、 (だいたい) \chirno; 周年だよ！
    }
    +p {
      \ruby[`あたい`]{|値|}みたいな天才目指して、
    }
    +p {
      頑張っていってねー！
    }>

    +subsection ?:(`コメント`) {コメント} <
    +p {
      この記事はC++11のパーフェクトフォワーディングについての記事です。これを読んで何かがわかるのかは良くわからないですけど生温かい視線で見ていただけると幸いです。
    }
    >
    >
    +section ?:(`rvalue-と-lvalue`) {rvalue と lvalue} <
    +quote<
    +p {
      キラキラ　C++
    }
    +p {
      輝く rvalue
    }
    +p {
      参照　\ruby[`右辺値`]{|rvalue|}　もなんとかして入ろう
    }
    +p {
      関数 変数　トップ目指して GO GO!!\footnote{
      この記事はC++11についての記事です。Go言語は関係ない
    }
    }>

    +subsection ?:(`解説`) {解説} <
    +p {
      C や C++ には rvalue (右辺値) と lvalue (左辺値) があります。元々は代入の左辺に置くことのできる値が lvalue (左辺値)、右辺にしか置けない値が rvalue (右辺値) という非常にわかりやすい区別でしたし、「参照」といえば左辺値の参照のことでした。
    }
    +code(`
    int return_int() {
      return 10;
    }
    void lvalue_reference(void) {
      // C++11より前は、右辺にある値がrvalueで左辺にある値がlvalueだった (非常に明快で良い)
      int alice_margatroid = return_int();
      // 当たり前だが、lvalueの参照を取ることができる
      int& pc98_alice = alice_margatroid; // 旧作のアリスはWin版のアリス・マーガトロイドと同一人物(らしい)
    }
    `);
    +p {
      ところが C++11で、rvalue でrvalue 参照 (右辺値参照) という左辺に置くことのできる rvalue が登場しました…という話を次の節でしていきます。
    }
    >
    >
    +section ?:(`rvalue-参照の例`) {rvalue 参照の例} <
    +quote<
    +p {
      バーカ！バーカ！バーカ！バーカ！バーカ！バーカ！)
    }
    +p {
      チルノ「ちょっ…違っ…rvalueじゃないもん！」
    }
    +p {
      (バーカ！バーカ！　バーカ！バーカ！バーカ！バーカ！)
    }
    +p {
      チルノ「左辺にある方がlvalueなのよぉ！」
    }>

    +code(`
    void rvalue_reference(void) {
      // C++11以降では&&でrvalueの参照も取ることができる様になった
      // chirnoは左辺にあるけどrvalueの参照なのでrvalue (正確にはeXpiring value、xvalue)
      // rvalue 参照はrvalueだけどlife timeが延長されて、式の外に出ても使うことができる。
      int&& chirno = return_int();
    `);
    +quote<
    +p {
      (バーカ！バーカ！バーカ！バーカ！バーカ！バーカ！)
    }
    +p {
      チルノ「なにようるさいわね　このrvalueっ！」
    }
    +p {
      (バーカ！バーカ！バーカ！バーカ！)
    }
    +p {
      ピチューン (life timeが終わって死んだ音)
    }>

    +code(`
      // 普通のrvalue (正確にはprvalue) は式が終わるとlife timeが終わる
      return_int();
      // ここでchirnoのlife timeが消える
      // 一方 return chirno; の様にすれば rvalue 参照 を返して引き続きlife timeを伸ばすこともできる
    }
    `);
    +subsection ?:(`解説-1`) {解説} <
    +p {
      C++11ではこれまで通りのrvalue (prvalue) に加えてrvalueの参照を作ることができる様になりました。 rvalue なのに参照とは？という点はとりあえず置いておいて、 rvalue の参照を使うことで rvalue を式の外でも使うことができる様になりました。
    }
    >
    >
    +section ?:(`rvalueの参照の存在意義-無駄なcopyを防ぐ`) {rvalueの参照の存在意義: 無駄なcopyを防ぐ} <
    +p {
      ここでは以下の \code(`Bus`); クラスを使います。
    }
    +code(`
    #include <iostream>
    #include <algorithm>

    class Bus {
    private:
      char * ptr; // C++11以降であればスマートポインタを使うべき
    public:
      Bus() {
        std::cout << "default constructor" << "\n";

        ptr = new char[3];
        // 本当は何か意味のあることをやる
      }
      // C++03以前でもできた、コピーコンストラクタ
      Bus(Bus const & bus) {
        std::cout << "copy constructor" << "\n";
        ptr = new char[3];
        // 受け取ったオブジェクトをコピーする
        std::copy(ptr, ptr + 3, bus.ptr);
      }
      // C++11以降でできる様になった、ムーブコンストラクタ
      // rvalueの参照を受け取った場合、受け取ったオブジェクトを破壊しても良い
      Bus(Bus && bus) {
        std::cout << "move constructor" << "\n";
        // 受け取ったオブジェクト中のptrをムーブして破壊する
        ptr = bus.ptr;
        bus.ptr = nullptr;
      }
      void print_ptr() {
        std::cout << std::hex << reinterpret_cast<size_t>(ptr) << "\n";
      }
      bool is_null() {
        return ptr == nullptr;
      }
      ~Bus() {
        delete [] ptr;
      }
    };
    `);
    +quote<
    +p {
      紅魔館からバスが出て始めに3人乗りました
    }>

    +code(`
    void copy_and_move() {
      Bus koumakan = Bus(); // 内部で charが3回newされる
      koumakan.print_ptr(); // TODO: 出力を書く
    `);
    +quote<
    +p {
      白玉楼にコピーして半人(はんじん)だけ乗りました
    }>

    +code(`
    Bus hakugyokurou = Bus(static_cast<const Bus&>(koumakan)); // コピーコンストラクタ。static_castは不要
    koumakan.print_ptr(); // TODO: 出力を書く
    hakugyokurou.print_ptr(); // TODO: 出力を書く
    `);
    +quote<
    +p {
      八雲さん家にムーブして 結局紅魔の乗客何人だ？
    }>

    +code(`
    Bus yakumo = Bus(static_cast<Bus&&>(koumakan)); // ムーブコンストラクタ。これ以降でkoumakanを使ってはいけない
    `);
    +quote<
    +p {
      答えは答えは　0人　0人
    }
    +p {
      なぜならなぜなら　そ・れ・は
    }
    +p {
      メモリ操作でムーブエンド
    }>

    +code(`
      koumakan.print_ptr(); // koumakan.ptr は nullptr なので 0が出力される
      hakugyokurou.print_ptr();  // TODO: 出力を書く
      yakumo.print_ptr(); // 元々 koumakan.ptr だったアドレスは yakumo.ptr に移った
    }
    `);
    +subsection ?:(`解説-2`) {解説} <
    +p {
      rvalue の参照ですが、無駄なメモリ上のcopyを防ぐために使います。より正確に言うと、 rvalue の参照として渡されたオブジェクトは破壊してもよい、というおやくそくがあります。 \code(`int`); や \code(`double`); などのプリミティブ型の場合は「破壊」と言っても特に何も破壊するものもありませんが、例えば上記例の \code(`Bus`); の場合には与えられたオブジェクトを破壊することで、コピーコンストラクタにある様にメモリの中身をコピーする代わりに、ムーブコンストラクタにある様にポインタの取り替えだけでオブジェクトを生成することができます。
    }
    >
    >
    +section ?:(`stdmove`) {std::move} <
    +quote<
    +p {
      キャストに　意味など無いわ
    }
    +p {
      rvalue 立てば　いいのよ
    }
    +p {
      std::moveがあれば　な・ん・で・も 1 2 9!
    }>

    +subsection ?:(`解説-3`) {解説} <
    +p {
      前述の例では \code(`static=cast<Bus&&>(koumakan)`); と書くことで \code(`koumakan`); の rvalue 参照を得ていましたが、これを毎回書くのはなかなか長いです。そこで出てくるのが標準ライブラリの \code(`std::move`); です。結局やっていることは \code(`static_cast`); と同じですが、 \code(`std::move`); を使うことで前述の例を以下の様に短かく書くことができます。
    }
    +code(`
    void copy_and_move2() {
      Bus koumakan = Bus(); // 内部で charが3回newされる
      koumakan.print_ptr();

      Bus hakugyokurou = Bus(koumakan); // コピーコンストラクタ。static_castは不要
      koumakan.print_ptr();
      hakugyokurou.print_ptr();
      Bus yakumo = Bus(std::move(koumakan)); // ムーブコンストラクタ。これ以降でkoumakanを使ってはいけない
      koumakan.print_ptr(); // koumakan.ptr は nullptr なので 0が出力される
      hakugyokurou.print_ptr();
      yakumo.print_ptr(); // 元々 koumakan.ptr だったアドレスは yakumo.ptr に移った
    }
    `);
    >
    >
    +section ?:(`universal参照-みんな大好きテンプレート`) {Universal参照: みんな大好きテンプレート} <
    +p {
      ここからは rvalue 参照や lvalue 参照とテンプレートの関係について見ていきます。
    }
    +quote<
    +p {
      くるくる　template　ぐるぐる　頭回る
    }
    +p {
      だって　\ruby[`つぶら目玉`]{|&|}　二つ(まで)しかないのに
    }
    +p {
      三本の \ruby[`針`]{|&|} なんて　ちんぷんかん
    }>

    +code(`
    #include <iostream>
    #include <type_traits>

    template<typename T>
    void print_if_ref(T&&) { // T が lvalue (参照) の場合は T&& は lvalue 参照に、T が rvalue (参照) の場合は T&& は rvalue 参照になる
      if (std::is_lvalue_reference<T&&>::value) {
        std::cout << "lvalue ref" << std::endl;
      } else if(std::is_rvalue_reference<T&&>::value) {
        std::cout << "rvalue ref" << std::endl;
      }
    }

    void universal() {
      int chirno = 9;
      print_if_ref(chirno); // lvalue ref
      print_if_ref(9); // rvalue ref
      int& chirno_ref = chirno;
      print_if_ref(chirno_ref); // lvalue ref
    }
    `);
    >
    +section ?:(`パーフェクトフォワーディング`) {パーフェクトフォワーディング} <
    +quote<
    +p {
      次々　参照出る　まだまだ　授業続く
    }
    +p {
      凍る　部屋の中
    }
    +p {
      参照の左辺も右辺も　気にせず
    }
    +p {
      ゆっくりしていってね!!!
    }>

    +code(`
    template<typename T>
    void universal_pass(T&& a) {
      print_if_ref(a);
    }

    template<typename T>
    void move_pass(T&& a) {
      print_if_ref(std::move(a));
    }

    template<typename T>
    void perfect_forwarding_pass(T&& a) {
      print_if_ref(std::forward<T>(a));
    }


    void universal() {
      int chirno = 9;
      universal_pass(chirno);
      universal_pass(9);
    }

    void move() {
      int chirno = 9;
      move_pass(chirno);
      move_pass(9);
    }
    void perfect_forward() {
      int chirno = 9;
      perfect_forwarding_pass(chirno);
      perfect_forwarding_pass(9);
    }
    `);
    >
    >
>

end
